# Л.Р. - 1 "Обычное матричное умножение является вычислительно неэффективным для больших матриц из-за кубической сложности"

Цао М.М.

ИУ10-36

## Задания
Для n от 1 до 10^5 ⋅ N c шагом 100 ⋅ N , где N = ( 20 − номер студента в списке группе ) , произведите для пяти запусков замер среднего машинного времени исполнения программ, реализующих нижеуказанные алгоритмы и функции.

Изобразите на графике полученные данные, отражающие зависимость среднего времени исполнения от n . Проведите теоретический анализ временной сложности рассматриваемых алгоритмов и сравните эмпирическую и теоретическую временные сложности.

### Задание 1 -  Провести теоретический и экспериментальный анализ временной сложности базовых операций над векторами для оценки их производительности на различных объемах данных.

    

```python
    # f1: Доступ к элементу по индексу (O(1))
    start_time = time.perf_counter()
    for _ in range(num_runs * 10000):  
        result = v[n // 2]
    times_f1.append((time.perf_counter() - start_time) / (num_runs * 10000))
    Пояснение: Самый быстрый тип операций, простое обращение к элементу массива по изв. индексу. Происходит за постоянное время и     не зависит от размера данных.
    
    # f4: Вычисление полинома методом Горнера (O(n))
    x_val = 1.0001
    start_time = time.perf_counter()
    for _ in range(num_runs):
        if n > 0:
            result = v[0]
            for k in range(1, n):
                result = result * x_val + v[k]
    times_f4.append((time.perf_counter() - start_time) / num_runs)
    Пояснение: Алгоритмически эффективный метод вычисления полиномов - выполняет n операций умножения и сложения.
    
    # f5: Поиск максимума простым перебором (O(n))
    start_time = time.perf_counter()
    for _ in range(num_runs * 100): 
        result = v[0]
        for k in range(1, n):
            if v[k] > result:
                result = v[k]
    times_f5.append((time.perf_counter() - start_time) / (num_runs * 100))
    Пояснение: Линейный поиск, требующий проверки каждого элемента массива один раз => время выполнения линейно зависит от n.
    
    # f7: Среднее арифметическое (O(n))
    start_time = time.perf_counter()
    for _ in range(num_runs):
        total = 0
        for k in range(n):
            total += v[k]
        result = total / n if n > 0 else 0
    times_f7.append((time.perf_counter() - start_time) / num_runs
    Пояснение: Такой же линейный алгоритм, требующий одного прохода по массиву для суммированя всех элементов и 1 операции деления.
    
    В итоге: Функции показывают ассимптотическую сложность: f1(O(1)) - наибыстрейшая ф-я, f4;f5;f7(O(n))- в этих ф-ях время линейно 
    растет с увеличением n.
    
    
    
**Выводы:**
1) Экспериментальные данные полностью соответствуют теоретическим предсказаниям, приведенным в методических материалах [1, 2, 4]. Как и утверждается в теоретической части, асимптотическое поведение функций при n → ∞ действительно определяется слагаемыми высшего порядка: f1 -> подтверждена сложность O(1). Cоответствует теоретическому пониманию операции индексирования в массивах как элементарной операции с фиксированным временем выполнения; f4,f5,f7 -> подтверждена линейная сложность O(n).
2) Выполнение эмпирического подхода -> результаты показывают, что при соблюдении одинаковых условий выполнения можно получить данные, достаточно точно отражающие асимптотическое поведение алгоритмов.
3) Эксперимент показал, что теоретический анализ временной сложности - это надежный инструмент для прогнозирования производительности алгоритмов на больших объемах данных. А эмпирические данные полностью подтверждают теоретические предсказания, что говорит о корректности как теоретических моделей, так и методики экспериментального исследования.
```

### Задание 2 - Исследование вычислительной сложности алгоритма обычного матричного умножения и демонстрация его неэффективности для больших матриц.
    1) Разумный диапазон для матричного умножения
    matrix_n_values = [1, 2, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60]
    Пояснение: Используем практический набор значений, достаточный для демонстрации кубической зависимости.
    
    2) Измерение времени и усреднение
        for run in range(num_runs):
        start_time = time.perf_counter()
        # операции умножения 
        end_time = time.perf_counter()
        times_matmul.append(end_time - start_time)
    average_times_matmul.append(sum(times_matmul) / num_runs)
    Пояснение: Точное измерение времени с помощью использования time.perf_counter() и усреднение по 5 запускам -> получаем статистически значимые результаты.
    3) На Рисунке 2 наблюдается характерный для O(n³) крутой рост времени выполнения...
    
**Выводы:**
1) Из-за с кубической сложности O(n³) алгоритма обычного матричного умножения, практическое исследование проводилось для n ≤ 60, что достаточно для демонстрации асимптотического поведения.
2) На логарифмическом графике время выполнения образует прямую линию с наклоном 3(примерно), что подтверждает кубическую зависимость времени выполнения от размера матриц.
3) Эксперимент наглядно демонстрирует, почему для больших матриц необходимо использовать оптимизированные алгоритмы т.к. обычное матричное умножение является вычислительно неэффективным для больших матриц из-за кубической сложности.
