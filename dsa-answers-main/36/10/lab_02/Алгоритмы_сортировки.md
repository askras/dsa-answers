# Классификация алгоритмов сортировки

---

## Сортировка деревом

### Основные характеристики
| Критерий | Классификация |
|----------|---------------|
| **Устойчивость** | Неустойчивая |
| **Тип сортировки** | Внутренняя |
| **Доп. память** | Не на месте |
| **Адаптивность** | Неадаптивная |

### Сложность алгоритма
| Сценарий | Сравнения C(n) | Перемещения M(n) |
|----------|----------------|------------------|
| **Лучший случай** | O(n log n) | O(n) |
| **Средний случай** | O(n log n) | O(n) |
| **Худший случай** | O(n²) | O(n) |

## Сортировка выбором

### Основные характеристики
| Критерий | Классификация |
|----------|---------------|
| **Устойчивость** | Неустойчивая |
| **Тип сортировки** | Внутренняя |
| **Доп. память** | На месте |
| **Адаптивность** | Неадаптивная |

### Сложность алгоритма
| Сценарий | Сравнения C(n) | Перемещения M(n) |
|----------|----------------|------------------|
| **Лучший случай** | O(n²) | O(1) |
| **Средний случай** | O(n²) | O(n) |
| **Худший случай** | O(n²) | O(n) |


# Теоретическое описание алгоритмов сортировки

---

## Сортировка деревом

Сортировка деревом использует структуру данных "бинарное дерево поиска" (BST) для организации элементов. Алгоритм состоит из двух основных этапов: построение дерева и обход дерева в порядке возрастания.

### Принцип работы
1. **Построение дерева**: Каждый элемент исходного массива последовательно вставляется в бинарное дерево поиска
2. **Обход дерева**: Выполняется симметричный (in-order) обход дерева, который возвращает элементы в отсортированном порядке

## Сортировка выбором

Алгоритм разделяет массив на две части: отсортированную (в начале) и неотсортированную (оставшаяся часть). На каждой итерации находится минимальный элемент из неотсортированной части и помещается в конец отсортированной части.

### Принцип работы
1. **Инициализация**: Отсортированная часть пуста, неотсортированная - весь массив
2. **Поиск минимума**: В неотсортированной части находится минимальный элемент
3. **Обмен**: Минимальный элемент меняется местами с первым элементом неотсортированной части
4. **Расширение**: Граница отсортированной части сдвигается на один элемент
5. **Повторение**: Шаги 2-4 повторяются пока есть неотсортированные элементы

# Блок-схемы алгоритмов

---

## Сортировка деревом

![png](Block-tree.png)

## Сортировка выбором

![png](Block-selection.png)

# Псевдокод

---

## Сортировка деревом

```
class TreeNode:
    value
    left
    right

function treeSort(arr):
    root = null
    for each value in arr:
        root = insert(root, value)
    result = []
    inorderTraversal(root, result)
    return result

function insert(node, value):
    if node is null:
        return new TreeNode(value)
    if value < node.value:
        node.left = insert(node.left, value)
    else:
        node.right = insert(node.right, value)
    return node

function inorderTraversal(node, result):
    if node is not null:
        inorderTraversal(node.left, result)
        result.append(node.value)
        inorderTraversal(node.right, result)
```

## Сортировка выбором

```
function selectionSort(arr):
    n = length(arr)
    for i from 0 to n-2:
        min_index = i
        for j from i+1 to n-1:
            if arr[j] < arr[min_index]:
                min_index = j
        swap arr[i] and arr[min_index]
    return arr
```

# Достоинства и недостатки

---

## Сортировка деревом

### Достоинства:
1. В среднем случае O(n log n)
2. Стабильная сложность для частично отсортированных данных

### Недостатки:
1. Требует O(n) дополнительной памяти
2. В худшем случае O(n²) для несбалансированного дерева
3. Сложная реализация

## Сортировка выбором

### Достоинства:
1. Простая реализация
2. In-place сортировка (O(1) дополнительной памяти)

### Недостатки:
1. Всегда O(n²) независимо от входных данных
2. Неустойчивая

## Реализация алгоритмов
---


```python
import time
import random
import sys
import matplotlib.pyplot as plt

sys.setrecursionlimit(200000)

# Сортировка деревом
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def tree_sort(arr):
    def insert(node, value):
        if node is None:
            return TreeNode(value)
        if value < node.value:
            node.left = insert(node.left, value)
        else:
            node.right = insert(node.right, value)
        return node
    
    def inorder_traversal(node, result):
        if node:
            inorder_traversal(node.left, result)
            result.append(node.value)
            inorder_traversal(node.right, result)
    
    root = None
    for value in arr:
        root = insert(root, value)
    
    result = []
    inorder_traversal(root, result)
    return result

# Сортировка выбором
def selection_sort(arr):
    n = len(arr)
    for i in range(n-1):
        min_index = i
        for j in range(i+1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr

def test_sorting_algorithms():
    test_arrays = [
        [64, 34, 25, 12, 22, 11, 90],
        [5, 2, 4, 6, 1, 3],
        [1],
        []
    ]
    
    for arr in test_arrays:
        tree_result = tree_sort(arr.copy())
        selection_result = selection_sort(arr.copy())
        expected = sorted(arr.copy())
        
        print(f"Исходный: {arr}")
        print(f"Tree sort: {tree_result}, Корректно: {tree_result == expected}")
        print(f"Selection sort: {selection_result}, Корректно: {selection_result == expected}")
        print()

test_sorting_algorithms()
```

    Исходный: [64, 34, 25, 12, 22, 11, 90]
    Tree sort: [11, 12, 22, 25, 34, 64, 90], Корректно: True
    Selection sort: [11, 12, 22, 25, 34, 64, 90], Корректно: True
    
    Исходный: [5, 2, 4, 6, 1, 3]
    Tree sort: [1, 2, 3, 4, 5, 6], Корректно: True
    Selection sort: [1, 2, 3, 4, 5, 6], Корректно: True
    
    Исходный: [1]
    Tree sort: [1], Корректно: True
    Selection sort: [1], Корректно: True
    
    Исходный: []
    Tree sort: [], Корректно: True
    Selection sort: [], Корректно: True
    


## Ручная трассировка

---
```
МАССИВ: [64, 25, 12, 22]
```

### Сортировка выбором
```
Итерация 0: [64, 25, 12, 22] min_index=2 → swap(0,2) → [12, 25, 64, 22]
Итерация 1: [12, 25, 64, 22] min_index=3 → swap(1,3) → [12, 22, 64, 25]
Итерация 2: [12, 22, 64, 25] min_index=3 → swap(2,3) → [12, 22, 25, 64]
Результат: [12, 22, 25, 64]
```

### Сортировка деревом
```
1) Построение дерева:

        [64]
        /  \
      [25] []
      /  \
    [12] []
    /  \
   []  [22]

2) Начинаем с корня 64:
Идем влево к 25
Идем влево к 12
У 12: левый потомок null → посещаем 12
Правый потомок 22 → идем к 22
У 22: левый потомок null → посещаем 22
Правый потомок null → возвращаемся
Возвращаемся к 12 (уже посещен) → возвращаемся к 25
Посещаем 25
Правый потомок 25 = null → возвращаемся к 64
Посещаем 64
Правый потомок 64 = null → обход завершен
посещения узлов: 12 → 22 → 25 → 64

Итоговый массив: [12, 22, 25, 64]
```

## Сравнение алгоритмов сортировки массивов, содержащих 1000, 5000, 10000 элементов.


```python
def performance_test():
    sizes = [1000, 5000, 10000]
    results = {'tree': [], 'selection': []}
    
    for size in sizes:
        print(f"\nТестирование для {size} элементов:")
        
        # Генерация тестовых данных
        sorted_arr = list(range(size))
        reverse_arr = list(range(size, 0, -1))
        random_arr = random.sample(range(size * 10), size)
        
        test_cases = {
            'Упорядоченный': sorted_arr,
            'Обратный порядок': reverse_arr,
            'Случайный': random_arr
        }
        
        for case_name, test_arr in test_cases.items():
            print(f"\n{case_name} массив:")
            
            arr_copy = test_arr.copy()
            start_time = time.time()
            tree_sort(arr_copy)
            tree_time = time.time() - start_time
            results['tree'].append((size, case_name, tree_time))
            print(f"Tree sort: {tree_time:.4f} сек")
            
            arr_copy = test_arr.copy()
            start_time = time.time()
            selection_sort(arr_copy)
            selection_time = time.time() - start_time
            results['selection'].append((size, case_name, selection_time))
            print(f"Selection sort: {selection_time:.4f} сек")
    
    return results

# Запуск тестов
results = performance_test()

# Построение графиков
def plot_results(results):
    sizes = [1000, 5000, 10000]
    cases = ['Упорядоченный', 'Обратный порядок', 'Случайный']
    
    fig, axes = plt.subplots(1, 2, figsize=(15, 5))
    
    # Tree sort
    for case in cases:
        times = [t for s, c, t in results['tree'] if c == case]
        axes[0].plot(sizes[:len(times)], times, marker='o', label=case)
    
    axes[0].set_title('Сортировка деревом')
    axes[0].set_xlabel('Размер массива')
    axes[0].set_ylabel('Время (сек)')
    axes[0].legend()
    axes[0].grid(True)
    
    # Selection sort
    for case in cases:
        times = [t for s, c, t in results['selection'] if c == case]
        if times:
            axes[1].plot(sizes[:len(times)], times, marker='o', label=case)
    
    axes[1].set_title('Сортировка выбором')
    axes[1].set_xlabel('Размер массива')
    axes[1].set_ylabel('Время (сек)')
    axes[1].legend()
    axes[1].grid(True)
    
    plt.tight_layout()
    plt.show()

plot_results(results)
```

    
    Тестирование для 1000 элементов:
    
    Упорядоченный массив:
    Tree sort: 0.0697 сек
    Selection sort: 0.0148 сек
    
    Обратный порядок массив:
    Tree sort: 0.0469 сек
    Selection sort: 0.0141 сек
    
    Случайный массив:
    Tree sort: 0.0007 сек
    Selection sort: 0.0141 сек
    
    Тестирование для 5000 элементов:
    
    Упорядоченный массив:
    Tree sort: 1.2768 сек
    Selection sort: 0.3397 сек
    
    Обратный порядок массив:
    Tree sort: 1.2933 сек
    Selection sort: 0.3571 сек
    
    Случайный массив:
    Tree sort: 0.0048 сек
    Selection sort: 0.3507 сек
    
    Тестирование для 10000 элементов:
    
    Упорядоченный массив:
    Tree sort: 5.5318 сек
    Selection sort: 1.4610 сек
    
    Обратный порядок массив:
    Tree sort: 5.7043 сек
    Selection sort: 1.4532 сек
    
    Случайный массив:
    Tree sort: 0.0144 сек
    Selection sort: 1.4123 сек



    
![png](output_3_1.png)
    


**Блок-схема для дерева**
``` LaTeX
\documentclass[tikz,border=10pt]{standalone}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows, positioning}

\tikzstyle{startstop} = [ellipse, draw, fill=gray!20, text width=4em, text centered, minimum height=2em]
\tikzstyle{process} = [rectangle, draw, fill=blue!10, text width=10em, text centered, rounded corners, minimum height=3em]
\tikzstyle{decision} = [diamond, draw, fill=orange!20, text width=7em, aspect=2, text centered, inner sep=0pt]
\tikzstyle{arrow} = [thick, ->, >=stealth]

\begin{document}

\begin{tikzpicture}[node distance=1.8cm]

% Nodes
\node (start) [startstop] {Начало};
\node (input) [process, below of=start] {Входной массив arr};
\node (initRoot) [process, below of=input] {root = None};
\node (initI) [process, below of=initRoot] {i = 0};
\node (checkLoop1) [decision, below of=initI, yshift=-0.5cm] {i < len(arr)?};
\node (insert) [process, below of=checkLoop1, yshift=-0.5cm] {root = insert(root, arr[i])};
\node (incrementI) [process, below of=insert] {i = i + 1};
\node (initResult) [process, right of=checkLoop1, xshift=4cm] {result = [ ]};
\node (traversal) [process, below of=initResult] {inorder\_traversal(root, result)};
\node (return) [process, below of=traversal] {Возврат result};
\node (stop) [startstop, below of=return] {Конец};

% Arrows
\draw [arrow] (start) -- (input);
\draw [arrow] (input) -- (initRoot);
\draw [arrow] (initRoot) -- (initI);
\draw [arrow] (initI) -- (checkLoop1);
\draw [arrow] (checkLoop1) -- node[anchor=east] {Да} (insert);
\draw [arrow] (insert) -- (incrementI);
\draw [arrow] (incrementI) -- ++(0,-0.5) -- ++(-3.5,0) |- (checkLoop1);
\draw [arrow] (checkLoop1) -- node[anchor=south] {Нет} (initResult);
\draw [arrow] (initResult) -- (traversal);
\draw [arrow] (traversal) -- (return);
\draw [arrow] (return) -- (stop);

\end{tikzpicture}

\end{document}
```

**Блок-схема для сортировки выбором**
``` LaTeX
\documentclass[tikz,border=10pt]{standalone}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows.meta, positioning}

\begin{document}

\tikzstyle{startstop} = [ellipse, draw, fill=gray!20, text width=4em, text centered, minimum height=2em]
\tikzstyle{process} = [rectangle, draw, fill=blue!10, text width=10em, text centered, rounded corners, minimum height=3em]
\tikzstyle{decision} = [diamond, draw, fill=orange!20, text width=7em, aspect=2, text centered, inner sep=0pt]
\tikzstyle{arrow} = [thick, ->, >=Stealth]

\begin{tikzpicture}[node distance=2cm]

% Nodes
\node (start) [startstop] {Начало};
\node (init) [process, below of=start] {n = len(arr), i = 0};
\node (check_i) [decision, below of=init, yshift=-0.5cm] {i < n-1?};
\node (set_min) [process, below of=check_i, yshift=-0.5cm] {min\_index = i, j = i+1};
\node (check_j) [decision, below of=set_min, yshift=-0.5cm] {j < n?};
\node (compare) [decision, below of=check_j, yshift=-0.5cm] {arr[j] < arr[min\_index]?};
\node (update_min) [process, right of=compare, xshift=4cm] {min\_index = j};
\node (inc_j) [process, below of=compare, yshift=-0.5cm] {j = j + 1};
\node (swap) [process, below of=inc_j, yshift=-0.5cm] {Поменять arr[i] и arr[min\_index]};
\node (inc_i) [process, below of=swap, yshift=-0.5cm] {i = i + 1};
\node (stop) [startstop, below of=inc_i] {Конец};

% Arrows
\draw [arrow] (start) -- (init);
\draw [arrow] (init) -- (check_i);
\draw [arrow] (check_i) -- node[anchor=west] {да} (set_min);
\draw [arrow] (check_i.east) -- ++(2,0) node[anchor=west] {нет} |- (stop);
\draw [arrow] (set_min) -- (check_j);
\draw [arrow] (check_j) -- node[anchor=west] {да} (compare);
\draw [arrow] (check_j.east) -- ++(2,0) node[anchor=west] {нет} |- (swap);
\draw [arrow] (compare) -- node[anchor=south] {да} (update_min);
\draw [arrow] (update_min) |- (inc_j);
\draw [arrow] (compare) -- node[anchor=west] {нет} (inc_j);
\draw [arrow] (inc_j) -- ++(-3.5,0) |- (check_j);
\draw [arrow] (swap) -- (inc_i);
\draw [arrow] (inc_i) -- ++(-3,0) |- (check_i);

\end{tikzpicture}

\end{document}
```


```python

```
