# Динамическое программирование

***

Старшинов Владислав Эдуардович

ИУ10-37

Вариант 6

## Задания

***

### Задача о рюкзаке с возможностью дробить предметы. Жадные алгоритмы


```python
def fractional_knapsack(capacity, items):
    """
    Решает задачу о дробном рюкзаке жадным алгоритмом.
    
    Args:
        capacity: максимальная вместимость рюкзака
        items: список кортежей (стоимость, вес, [количество])
    
    Returns:
        tuple: (максимальная стоимость, список выбранных предметов)
    """
    # Сортируем предметы по убыванию стоимости за единицу веса
    sorted_items = sorted(items, key=lambda x: x[0]/x[1], reverse=True)
    
    total_value = 0.0
    current_weight = 0.0
    selected_items = []
    
    for value, weight, *rest in sorted_items:
        # Если предмет полностью помещается
        if current_weight + weight <= capacity:
            total_value += value
            current_weight += weight
            selected_items.append((value, weight, 1.0))  # 1.0 = взято полностью
        else:
            # Берем только часть предмета
            remaining_capacity = capacity - current_weight
            fraction = remaining_capacity / weight
            total_value += value * fraction
            selected_items.append((value, weight, fraction))
            break  # Рюкзак заполнен
    
    return total_value, selected_items

def fractional_knapsack_with_quantities(capacity, items):
    """
    Расширенная версия с учетом количества каждого предмета.
    
    Args:
        capacity: максимальная вместимость рюкзака
        items: список кортежей (стоимость, вес, количество)
    
    Returns:
        tuple: (максимальная стоимость, список выбранных предметов)
    """
    # Создаем расширенный список предметов с учетом количества
    expanded_items = []
    for value, weight, quantity in items:
        expanded_items.extend([(value, weight)] * quantity)
    
    # Сортируем по убыванию стоимости за единицу веса
    sorted_items = sorted(expanded_items, key=lambda x: x[0]/x[1], reverse=True)
    
    total_value = 0.0
    current_weight = 0.0
    selected_items = []
    
    for value, weight in sorted_items:
        if current_weight >= capacity:
            break
            
        if current_weight + weight <= capacity:
            # Берем предмет полностью
            total_value += value
            current_weight += weight
            selected_items.append((value, weight, 1.0))
        else:
            # Берем часть предмета
            remaining_capacity = capacity - current_weight
            fraction = remaining_capacity / weight
            total_value += value * fraction
            selected_items.append((value, weight, fraction))
            break
    
    return total_value, selected_items
```

### Задача о покрытии отрезками. Жадные алгоритмы


```python
def segment_cover(target_segment, segments):
    """
    Находит минимальное количество отрезков, покрывающих целевой отрезок.
    
    Args:
        target_segment: кортеж (start, end) - целевой отрезок
        segments: список кортежей [(start1, end1), (start2, end2), ...]
    
    Returns:
        tuple: (минимальное количество отрезков, список выбранных отрезков)
    """
    target_start, target_end = target_segment
    
    # Фильтруем отрезки, которые пересекаются с целевым отрезком
    valid_segments = []
    for seg in segments:
        seg_start, seg_end = seg
        # Отрезок пересекается с целевым, если его конец >= начала целевого и начало <= конца целевого
        if seg_end >= target_start and seg_start <= target_end:
            valid_segments.append(seg)
    
    # Сортируем отрезки по правому концу (по возрастанию)
    valid_segments.sort(key=lambda x: x[1])
    
    selected_segments = []
    current_position = target_start  # Текущая позиция, которую нужно покрыть
    i = 0
    n = len(valid_segments)
    
    while current_position < target_end and i < n:
        best_segment = None
        # Ищем отрезок, который начинается не позже current_position и имеет максимальный правый конец
        while i < n and valid_segments[i][0] <= current_position:
            if best_segment is None or valid_segments[i][1] > best_segment[1]:
                best_segment = valid_segments[i]
            i += 1
        
        # Если не нашли подходящий отрезок - покрытие невозможно
        if best_segment is None:
            return float('inf'), []  # Невозможно покрыть
        
        selected_segments.append(best_segment)
        current_position = best_segment[1]  # Перемещаем текущую позицию к концу выбранного отрезка
    
    # Проверяем, покрыли ли весь целевой отрезок
    if current_position < target_end:
        return float('inf'), []  # Не удалось покрыть полностью
    
    return len(selected_segments), selected_segments
```

### Задача о нахождении наименьшего пути. Динамическое программирование.


```python
import sys
from typing import List, Tuple, Dict

def floyd_warshall(graph: List[List[int]]) -> Tuple[List[List[int]], List[List[int]]]:
    """
    Алгоритм Флойда-Уоршелла для нахождения кратчайших путей между всеми парами вершин.
    
    Args:
        graph: матрица смежности n x n, где graph[i][j] - вес ребра из i в j,
               INF если ребра нет, 0 если i == j
    
    Returns:
        tuple: (матрица кратчайших расстояний, матрица предков для восстановления путей)
    """
    n = len(graph)
    
    # Инициализация матрицы расстояний и матрицы предков
    dist = [[0] * n for _ in range(n)]
    next_vertex = [[-1] * n for _ in range(n)]
    
    # Копируем исходный граф и инициализируем матрицу предков
    for i in range(n):
        for j in range(n):
            dist[i][j] = graph[i][j]
            if graph[i][j] != float('inf') and i != j:
                next_vertex[i][j] = j
            elif i == j:
                next_vertex[i][j] = i
    
    # Основной алгоритм
    for k in range(n):
        for i in range(n):
            for j in range(n):
                # Если путь через вершину k короче
                if dist[i][k] != float('inf') and dist[k][j] != float('inf'):
                    if dist[i][j] > dist[i][k] + dist[k][j]:
                        dist[i][j] = dist[i][k] + dist[k][j]
                        next_vertex[i][j] = next_vertex[i][k]
    
    return dist, next_vertex

def reconstruct_path(start: int, end: int, next_vertex: List[List[int]]) -> List[int]:
    """
    Восстанавливает кратчайший путь между start и end.
    
    Args:
        start: начальная вершина
        end: конечная вершина
        next_vertex: матрица предков
    
    Returns:
        list: список вершин пути или пустой список если пути нет
    """
    if next_vertex[start][end] == -1:
        return []  # Пути не существует
    
    path = [start]
    current = start
    
    while current != end:
        current = next_vertex[current][end]
        path.append(current)
    
    return path

def print_all_pairs_shortest_paths(dist: List[List[int]], next_vertex: List[List[int]]):
    """
    Выводит все кратчайшие пути между парами вершин.
    """
    n = len(dist)
    
    print("Матрица кратчайших расстояний:")
    print("    " + "   ".join(f"{i:2}" for i in range(n)))
    print("   " + "-" * (4 * n))
    
    for i in range(n):
        print(f"{i:2}|", end=" ")
        for j in range(n):
            if dist[i][j] == float('inf'):
                print(" INF", end=" ")
            else:
                print(f"{dist[i][j]:4.1f}", end=" ")
        print()
    
    print("\nКратчайшие пути:")
    for i in range(n):
        for j in range(n):
            if i != j:
                path = reconstruct_path(i, j, next_vertex)
                if path:
                    path_str = " -> ".join(map(str, path))
                    print(f"{i} -> {j}: {path_str} (расстояние: {dist[i][j]})")
                else:
                    print(f"{i} -> {j}: пути не существует")

def detect_negative_cycles(dist: List[List[int]]) -> bool:
    """
    Обнаруживает наличие отрицательных циклов в графе.
    
    Returns:
        bool: True если есть отрицательные циклы, иначе False
    """
    n = len(dist)
    for i in range(n):
        if dist[i][i] < 0:
            return True
    return False
```

### Задача о размене монет. Динамическое программирование.


```python
def coin_change_min_coins(coins, amount):
    """
    Находит минимальное количество монет для составления заданной суммы.
    
    Args:
        coins: список номиналов монет
        amount: целевая сумма
    
    Returns:
        int: минимальное количество монет или -1 если сумму невозможно составить
    """
    # Инициализация массива dp
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Базовый случай: для суммы 0 нужно 0 монет
    
    # Заполнение массива dp
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1

def coin_change_with_reconstruction(coins, amount):
    """
    Находит минимальное количество монет и восстанавливает комбинацию.
    
    Args:
        coins: список номиналов монет
        amount: целевая сумма
    
    Returns:
        tuple: (мин. количество монет, список использованных монет) или (-1, [])
    """
    dp = [float('inf')] * (amount + 1)
    coin_used = [-1] * (amount + 1)  # Для хранения последней использованной монеты
    dp[0] = 0
    
    # Заполнение массивов
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin and dp[i - coin] + 1 < dp[i]:
                dp[i] = dp[i - coin] + 1
                coin_used[i] = coin
    
    # Восстановление комбинации монет
    if dp[amount] == float('inf'):
        return -1, []
    
    # Восстанавливаем комбинацию
    combination = []
    current_amount = amount
    while current_amount > 0:
        coin = coin_used[current_amount]
        combination.append(coin)
        current_amount -= coin
    
    return dp[amount], combination

def coin_change_all_combinations(coins, amount):
    """
    Находит количество всех возможных комбинаций для размена суммы.
    
    Args:
        coins: список номиналов монет
        amount: целевая сумма
    
    Returns:
        int: количество различных комбинаций
    """
    dp = [0] * (amount + 1)
    dp[0] = 1  # Один способ составить сумму 0 - не использовать монеты
    
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]
    
    return dp[amount]
```

### Генерация разбиений множества. Комбинаторные алгоритмы.


```python
from typing import List, Set, Any

def generate_set_partitions(elements: List[Any]) -> List[List[List[Any]]]:
    """
    Генерирует все возможные разбиения множества на подмножества.
    
    Args:
        elements: список элементов множества
    
    Returns:
        список всех возможных разбиений, где каждое разбиение - список подмножеств
    """
    if not elements:
        return [[]]
    
    result = []
    first_element = elements[0]
    remaining_elements = elements[1:]
    
    # Рекурсивно генерируем разбиения для оставшихся элементов
    smaller_partitions = generate_set_partitions(remaining_elements)
    
    for partition in smaller_partitions:
        # Вариант 1: Добавляем первый элемент как новое подмножество
        result.append([[first_element]] + partition)
        
        # Вариант 2: Добавляем первый элемент в каждое существующее подмножество
        for i in range(len(partition)):
            new_partition = [subset.copy() for subset in partition]
            new_partition[i] = [first_element] + new_partition[i]
            result.append(new_partition)
    
    return result

def bell_number(n: int) -> int:
    """
    Вычисляет число Белла - количество всех разбиений множества из n элементов.
    """
    if n == 0:
        return 1
    
    bell = [[0] * (n + 1) for _ in range(n + 1)]
    bell[0][0] = 1
    
    for i in range(1, n + 1):
        bell[i][0] = bell[i - 1][i - 1]
        for j in range(1, i + 1):
            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]
    
    return bell[n][0]

def generate_partitions_by_size(elements: List[Any], k: int = 0) -> List[List[List[Any]]]:
    """
    Генерирует разбиения на заданное количество подмножеств или все разбиения если k не указано.
    
    Args:
        elements: список элементов
        k: количество подмножеств (опционально)
    
    Returns:
        список разбиений
    """
    all_partitions = generate_set_partitions(elements)
    
    if k is None:
        return all_partitions
    
    return [partition for partition in all_partitions if len(partition) == k]

def stirling_number_second_kind(n: int, k: int) -> int:
    """
    Вычисляет число Стирлинга второго рода S(n, k) - количество разбиений
    n-элементного множества на k непустых подмножеств.
    """
    if k == 0 or n == 0:
        return 0
    if k == 1 or k == n:
        return 1
    if k > n:
        return 0
    
    # Используем рекуррентное соотношение:
    # S(n, k) = S(n-1, k-1) + k * S(n-1, k)
    dp = [[0] * (k + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for j in range(1, min(i, k) + 1):
            if j == 1 or i == j:
                dp[i][j] = 1
            else:
                dp[i][j] = dp[i - 1][j - 1] + j * dp[i - 1][j]
    
    return dp[n][k]

def validate_partition(elements: List[Any], partition: List[List[Any]]) -> bool:
    """
    Проверяет корректность разбиения множества.
    """
    # Все элементы должны присутствовать
    all_elements = [item for subset in partition for item in subset]
    
    # Проверяем что все исходные элементы присутствуют
    if set(all_elements) != set(elements):
        return False
    
    # Проверяем что нет повторяющихся элементов
    if len(all_elements) != len(elements):
        return False
    
    # Проверяем что подмножества не пересекаются
    total_size = sum(len(subset) for subset in partition)
    if total_size != len(elements):
        return False
    
    return True

# Дополнительная проверка
if __name__ == "__main__":
    print("\n" + "=" * 60)
    print("ПРОВЕРКА КОРРЕКТНОСТИ")
    print("=" * 60)
    
    test_elements = [1, 2, 3]
    test_partitions = generate_set_partitions(test_elements)
    
    print("Проверка всех разбиений на корректность:")
    all_valid = True
    for i, partition in enumerate(test_partitions, 1):
        is_valid = validate_partition(test_elements, partition)
        status = "✓" if is_valid else "✗"
        partition_str = " | ".join("{" + ", ".join(map(str, subset)) + "}" for subset in partition)
        print(f"{status} {i:2}. {partition_str}")
        all_valid = all_valid and is_valid
    
    print(f"\nВсе разбиения корректны: {all_valid}")
```
