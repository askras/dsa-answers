```python

```


```python
from collections import defaultdict
import heapq

class Graph:
    def __init__(self, directed=False):
        self.graph = defaultdict(dict)
        self.directed = directed
        self.vertices = set()
    
    def add_vertex(self, vertex):
        self.vertices.add(vertex)
        if vertex not in self.graph:
            self.graph[vertex] = {}
    
    def add_edge(self, u, v, weight=1):
        self.add_vertex(u)
        self.add_vertex(v)
        self.graph[u][v] = weight
        if not self.directed:
            self.graph[v][u] = weight
    
    def dijkstra(self, start, end):
        """Алгоритм Дейкстры для поиска кратчайшего пути от start до end"""
        if start not in self.graph or end not in self.vertices:
            return None, float('infinity')
        
        distances = {vertex: float('infinity') for vertex in self.vertices}
        distances[start] = 0
        previous = {vertex: None for vertex in self.vertices}
        priority_queue = [(0, start)]
        
        while priority_queue:
            current_distance, current_vertex = heapq.heappop(priority_queue)
            
            # Если дошли до конечной вершины
            if current_vertex == end:
                break
                
            if current_distance > distances[current_vertex]:
                continue
            
            for neighbor, weight in self.graph[current_vertex].items():
                distance = current_distance + weight
                
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current_vertex
                    heapq.heappush(priority_queue, (distance, neighbor))
        
        # Восстанавливаем путь
        if distances[end] == float('infinity'):
            return None, float('infinity')
        
        path = []
        current = end
        while current is not None:
            path.append(current)
            current = previous[current]  # Исправлено: используем словарь previous
        
        path.reverse()
        return path, distances[end]
    
    def dijkstra_all_paths(self, start):
        """Алгоритм Дейкстры для поиска всех кратчайших путей от start"""
        if start not in self.graph:
            return {}, {}
        
        distances = {vertex: float('infinity') for vertex in self.vertices}
        distances[start] = 0
        previous = {vertex: None for vertex in self.vertices}
        priority_queue = [(0, start)]
        
        while priority_queue:
            current_distance, current_vertex = heapq.heappop(priority_queue)
            
            if current_distance > distances[current_vertex]:
                continue
            
            for neighbor, weight in self.graph[current_vertex].items():
                distance = current_distance + weight
                
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current_vertex
                    heapq.heappush(priority_queue, (distance, neighbor))
        
        return distances, previous
    
    def print_all_paths_from_start(self, start):
        """Вывести все кратчайшие пути от стартовой вершины"""
        distances, previous = self.dijkstra_all_paths(start)  # Исправлено: используем правильный метод
        
        print(f"\nКратчайшие пути от вершины {start}:")
        print("Вершина | Расстояние | Путь")
        print("-" * 40)
        
        for vertex in sorted(self.vertices):
            if vertex == start:
                continue
                
            # Восстанавливаем путь для каждой вершины
            path = []
            current = vertex
            while current is not None:
                path.append(current)
                current = previous[current]  # Исправлено: используем словарь previous
            
            path.reverse()
            
            # Исправлено: правильно обращаемся к distances
            dist = distances.get(vertex, float('infinity'))
            if dist == float('infinity'):
                path_str = "Нет пути"
            else:
                path_str = ' → '.join(map(str, path))
            
            print(f"{vertex:7} | {dist:9} | {path_str}")

# Создаем неориентированный граф на основе предоставленных данных
graph = Graph(directed=False)

# Добавляем ребра с весами
edges = [
    (1, 2, 14), (1, 6, 8),
    (2, 6, 2), (2, 4, 10), (2, 5, 2), (2, 3, 5), (2, 8, 9),
    (3, 8, 11),
    (4, 6, 6), (4, 7, 5), (4, 5, 3),
    (5, 7, 8), (5, 8, 1),
    (6, 7, 5),
    (7, 8, 7)
]

for u, v, weight in edges:
    graph.add_edge(u, v, weight)

# Находим кратчайший путь от вершины 3 до вершины 8
start_vertex = 3
end_vertex = 8
path, distance = graph.dijkstra(start_vertex, end_vertex)

print("АЛГОРИТМ ДЕЙКСТРЫ - ПОИСК КРАТЧАЙШЕГО ПУТИ")
print("=" * 60)
print(f"Начальная вершина: {start_vertex}")
print(f"Конечная вершина: {end_vertex}")
print("=" * 60)

if path:
    print(f"КРАТЧАЙШИЙ ПУТЬ: {' → '.join(map(str, path))}")
    print(f"ДЛИНА ПУТИ: {distance}")
    
    # Подробный расчет
    print("\nПОДРОБНЫЙ РАСЧЕТ:")
    total = 0
    for i in range(len(path) - 1):
        u, v = path[i], path[i + 1]
        edge_weight = graph.graph[u][v]
        total += edge_weight
        print(f"  {u} → {v} = {edge_weight}")
    print(f"  ИТОГО: {total}")
else:
    print("Путь не существует")

# Анализ всех возможных маршрутов от 3 до 8
print("\n" + "=" * 60)
print("АНАЛИЗ ВОЗМОЖНЫХ МАРШРУТОВ ОТ 3 ДО 8:")
print("=" * 60)

possible_routes = [
    [3, 8],                    # Прямой путь
    [3, 2, 8],                 # Через вершину 2
    [3, 2, 5, 8],              # Через вершины 2 и 5
    [3, 2, 6, 7, 8],           # Через вершины 2, 6, 7
    [3, 2, 4, 5, 8],           # Через вершины 2, 4, 5
    [3, 2, 6, 4, 5, 8]         # Через вершины 2, 6, 4, 5
]

print("Все возможные маршруты от 3 до 8:")
for i, route in enumerate(possible_routes, 1):
    total_distance = 0
    valid_route = True
    route_details = []
    
    for j in range(len(route) - 1):
        u, v = route[j], route[j + 1]
        if v in graph.graph[u]:
            edge_weight = graph.graph[u][v]
            total_distance += edge_weight
            route_details.append(f"{u}→{v}({edge_weight})")
        else:
            valid_route = False
            break
    
    if valid_route:
        status = "✓" if total_distance == distance else ""
        print(f"{i:2}. {route} = {total_distance:2} {status}")
        if route_details:
            print(f"    {' + '.join(route_details)}")

# Выводим все кратчайшие пути от вершины 3
graph.print_all_paths_from_start(3)  # Исправлено: передаем int, а не список

print("\n" + "=" * 60)
print("ОСНОВНОЙ ВЫВОД:")
print("=" * 60)
print(f"Кратчайший путь от {start_vertex} до {end_vertex}: {path}")
print(f"Длина кратчайшего пути: {distance}")
```
