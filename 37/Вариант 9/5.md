```python
# Задание 1: Хеш-таблица на основе метода цепочек

class Node:
    """Узел для цепочек"""
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None

class ChainingHashTable:
    def __init__(self, capacity=10):
        self.capacity = capacity
        self.size = 0
        self.table = [None] * capacity
        self.load_factor_threshold = 0.75
    
    def _hash(self, key):
        """Хеш-функция"""
        return hash(key) % self.capacity
    
    def _resize(self):
        """Увеличение размера таблицы при необходимости"""
        if self.size / self.capacity < self.load_factor_threshold:
            return
        
        old_table = self.table
        self.capacity *= 2
        self.table = [None] * self.capacity
        self.size = 0
        
        for head in old_table:
            current = head
            while current:
                self.put(current.key, current.value)
                current = current.next
    
    def put(self, key, value):
        """Добавление элемента"""
        self._resize()
        index = self._hash(key)
        
        if self.table[index] is None:
            self.table[index] = Node(key, value)
            self.size += 1
            return
        
        current = self.table[index]
        while current:
            if current.key == key:
                current.value = value
                return
            if current.next is None:
                break
            current = current.next
        
        current.next = Node(key, value)
        self.size += 1
    
    def get(self, key):
        """Получение значения по ключу"""
        index = self._hash(key)
        current = self.table[index]
        
        while current:
            if current.key == key:
                return current.value
            current = current.next
        
        raise KeyError(f"Key {key} not found")
    
    def delete(self, key):
        """Удаление элемента"""
        index = self._hash(key)
        current = self.table[index]
        prev = None
        
        while current:
            if current.key == key:
                if prev:
                    prev.next = current.next
                else:
                    self.table[index] = current.next
                self.size -= 1
                return
            prev = current
            current = current.next
        
        raise KeyError(f"Key {key} not found")
    
    def contains(self, key):
        """Проверка наличия ключа"""
        try:
            self.get(key)
            return True
        except KeyError:
            return False
    
    def __str__(self):
        result = []
        for i, head in enumerate(self.table):
            chain = []
            current = head
            while current:
                chain.append(f"({current.key}: {current.value})")
                current = current.next
            if chain:
                result.append(f"Bucket {i}: {' -> '.join(chain)}")
        return "\n".join(result)
```

```python
# Задание 2: Хеш-таблица на основе открытой адресации

class OpenAddressingHashTable:
    def __init__(self, capacity=10):
        self.capacity = capacity
        self.size = 0
        self.table = [None] * capacity
        self.deleted = [False] * capacity
        self.load_factor_threshold = 0.7
    
    def _hash(self, key, i=0):
        """Хеш-функция с линейным пробированием"""
        return (hash(key) + i) % self.capacity
    
    def _resize(self):
        """Увеличение размера таблицы"""
        if self.size / self.capacity < self.load_factor_threshold:
            return
        
        old_table = self.table
        old_deleted = self.deleted
        self.capacity *= 2
        self.table = [None] * self.capacity
        self.deleted = [False] * self.capacity
        self.size = 0
        
        for i in range(len(old_table)):
            if old_table[i] is not None and not old_deleted[i]:
                self.put(old_table[i][0], old_table[i][1])
    
    def put(self, key, value):
        """Добавление элемента"""
        self._resize()
        
        for i in range(self.capacity):
            index = self._hash(key, i)
            
            if self.table[index] is None or self.deleted[index]:
                self.table[index] = (key, value)
                self.deleted[index] = False
                self.size += 1
                return
            elif self.table[index][0] == key:
                self.table[index] = (key, value)
                return
        
        raise Exception("Hash table is full")
    
    def get(self, key):
        """Получение значения по ключу"""
        for i in range(self.capacity):
            index = self._hash(key, i)
            
            if self.table[index] is None and not self.deleted[index]:
                break
            if not self.deleted[index] and self.table[index] is not None and self.table[index][0] == key:
                return self.table[index][1]
        
        raise KeyError(f"Key {key} not found")
    
    def delete(self, key):
        """Удаление элемента"""
        for i in range(self.capacity):
            index = self._hash(key, i)
            
            if self.table[index] is None and not self.deleted[index]:
                break
            if not self.deleted[index] and self.table[index] is not None and self.table[index][0] == key:
                self.deleted[index] = True
                self.size -= 1
                return
        
        raise KeyError(f"Key {key} not found")
    
    def contains(self, key):
        """Проверка наличия ключа"""
        try:
            self.get(key)
            return True
        except KeyError:
            return False
    
    def __str__(self):
        result = []
        for i in range(self.capacity):
            if self.table[i] is not None and not self.deleted[i]:
                result.append(f"Index {i}: ({self.table[i][0]}: {self.table[i][1]})")
            elif self.deleted[i]:
                result.append(f"Index {i}: [DELETED]")
            else:
                result.append(f"Index {i}: None")
        return "\n".join(result)

```


```python
# Задание 3: Блокчейн

import hashlib
import time

class Block:
    def __init__(self, index, timestamp, data, previous_hash):
        self.index = index
        self.timestamp = timestamp
        self.data = data
        self.previous_hash = previous_hash
        self.hash = self.calculate_hash()
    
    def calculate_hash(self):
        """Вычисление хеша блока"""
        block_string = f"{self.index}{self.timestamp}{self.data}{self.previous_hash}"
        return hashlib.sha256(block_string.encode()).hexdigest()
    
    def __str__(self):
        return f"Block {self.index} [Hash: {self.hash}, Previous: {self.previous_hash}, Data: {self.data}]"

class Blockchain:
    def __init__(self):
        self.chain = [self.create_genesis_block()]
    
    def create_genesis_block(self):
        """Создание генезис-блока (первого блока)"""
        return Block(0, time.time(), "Genesis Block", "0")
    
    def get_latest_block(self):
        """Получение последнего блока"""
        return self.chain[-1]
    
    def add_block(self, data):
        """Добавление нового блока"""
        latest_block = self.get_latest_block()
        new_block = Block(
            index=len(self.chain),
            timestamp=time.time(),
            data=data,
            previous_hash=latest_block.hash
        )
        self.chain.append(new_block)
    
    def is_chain_valid(self):
        """Проверка целостности блокчейна"""
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i-1]
            
            # Проверка хеша текущего блока
            if current_block.hash != current_block.calculate_hash():
                return False
            
            # Проверка связи с предыдущим блоком
            if current_block.previous_hash != previous_block.hash:
                return False
        
        return True
    
    def __str__(self):
        return "\n".join(str(block) for block in self.chain)
```


```python
# Задание 4: Проверка пересечения двух массивов

def array_intersection(arr1, arr2):
    """Проверка пересечения двух массивов"""
    hash_set = set(arr1)
    
    for element in arr2:
        if element in hash_set:
            return True
    
    return False

# Тестирование алгоритмов

print("\nТестирование алгоритмов" )
```

    
    Тестирование алгоритмов
    


```python
# Задание 5: Проверка уникальности элементов в массиве

def all_unique_elements(arr):
    """Проверка уникальности всех элементов"""
    hash_set = set()
    
    for element in arr:
        if element in hash_set:
            return False
        hash_set.add(element)
    
    return True
```


```python
# Задание 6: Нахождение пар с заданной суммой

def find_pairs_with_sum(arr, target_sum):
    """Нахождение всех пар чисел с заданной суммой"""
    hash_map = {}
    pairs = []
    
    for i, num in enumerate(arr):
        complement = target_sum - num
        
        if complement in hash_map:
            for index in hash_map[complement]:
                pairs.append((arr[index], num))
        
        if num not in hash_map:
            hash_map[num] = []
        hash_map[num].append(i)
    
    return pairs
```


```python
# Задание 7: Проверка анаграмм

def are_anagrams(str1, str2):
    """Проверка, являются ли строки анаграммами"""
    if len(str1) != len(str2):
        return False
    
    char_count = {}
    
    # Подсчет символов в первой строке
    for char in str1:
        char_count[char] = char_count.get(char, 0) + 1
    
    # Проверка второй строки
    for char in str2:
        if char not in char_count:
            return False
        char_count[char] -= 1
        if char_count[char] == 0:
            del char_count[char]
    
    return len(char_count) == 0
```


```python
# Тестирование хеш-таблиц

print("=== Тестирование хеш-таблицы методом цепочек ===")
cht = ChainingHashTable(5)
cht.put("apple", 1)
cht.put("banana", 2)
cht.put("orange", 3)
cht.put("grape", 4)
print(cht)
print("Получение 'apple':", cht.get("apple"))
print("Содержит 'banana':", cht.contains("banana"))
cht.delete("banana")
print("После удаления 'banana':")
print(cht)

print("\n=== Тестирование хеш-таблицы методом открытой адресации ===")
oaht = OpenAddressingHashTable(5)
oaht.put("apple", 1)
oaht.put("banana", 2)
oaht.put("orange", 3)
print(oaht)
print("Получение 'orange':", oaht.get("orange"))
oaht.delete("banana")
print("После удаления 'banana':")
print(oaht)

# Тестирование блокчейна

print("\n=== Тестирование блокчейна ===")
blockchain = Blockchain()
blockchain.add_block("Transaction 1: Alice -> Bob 5 BTC")
blockchain.add_block("Transaction 2: Bob -> Charlie 3 BTC")
blockchain.add_block("Transaction 3: Charlie -> Dave 1 BTC")

print(blockchain)
print("Цепочка валидна:", blockchain.is_chain_valid())

# Попробуем изменить данные в блоке
print("\nПопытка изменения данных...")
blockchain.chain[1].data = "Transaction 1: Alice -> Eve 10 BTC"
print("Цепочка валидна после изменения:", blockchain.is_chain_valid())



# Задание 4
arr1 = [1, 2, 3, 4, 5]
arr2 = [6, 7, 8, 9, 10]
arr3 = [5, 6, 7, 8, 9]
print("Пересечение arr1 и arr2:", array_intersection(arr1, arr2))
print("Пересечение arr1 и arr3:", array_intersection(arr1, arr3))

# Задание 5
unique_arr = [1, 2, 3, 4, 5]
duplicate_arr = [1, 2, 3, 2, 4]
print("Все элементы unique_arr уникальны:", all_unique_elements(unique_arr))
print("Все элементы duplicate_arr уникальны:", all_unique_elements(duplicate_arr))

# Задание 6
numbers = [2, 7, 11, 15, 3, 6, 8]
target = 9
pairs = find_pairs_with_sum(numbers, target)
print(f"Пары с суммой {target} в массиве {numbers}: {pairs}")

# Задание 7
str1 = "listen"
str2 = "silent"
str3 = "hello"
str4 = "world"
print(f"'{str1}' и '{str2}' являются анаграммами:", are_anagrams(str1, str2))
print(f"'{str3}' и '{str4}' являются анаграммами:", are_anagrams(str3, str4))


```

    === Тестирование хеш-таблицы методом цепочек ===
    Bucket 0: (banana: 2)
    Bucket 2: (apple: 1)
    Bucket 3: (orange: 3) -> (grape: 4)
    Получение 'apple': 1
    Содержит 'banana': True
    После удаления 'banana':
    Bucket 2: (apple: 1)
    Bucket 3: (orange: 3) -> (grape: 4)
    
    === Тестирование хеш-таблицы методом открытой адресации ===
    Index 0: (banana: 2)
    Index 1: None
    Index 2: (apple: 1)
    Index 3: (orange: 3)
    Index 4: None
    Получение 'orange': 3
    После удаления 'banana':
    Index 0: [DELETED]
    Index 1: None
    Index 2: (apple: 1)
    Index 3: (orange: 3)
    Index 4: None
    
    === Тестирование блокчейна ===
    Block 0 [Hash: 90a951958f1d6992a7c12faa7892c348d4c900ed0856bd47228b53ee53bcd51e, Previous: 0, Data: Genesis Block]
    Block 1 [Hash: 470d7943b9a5dd30f23d65cc9e3dff665b63f4b7afeed8af41d523ee72fbd5e1, Previous: 90a951958f1d6992a7c12faa7892c348d4c900ed0856bd47228b53ee53bcd51e, Data: Transaction 1: Alice -> Bob 5 BTC]
    Block 2 [Hash: 764550ac612859709259b70e7b0145e9b5ec6469b2be288d24aa227eeeaf9fa0, Previous: 470d7943b9a5dd30f23d65cc9e3dff665b63f4b7afeed8af41d523ee72fbd5e1, Data: Transaction 2: Bob -> Charlie 3 BTC]
    Block 3 [Hash: 3f3212b7714140cfaccf91f6979f15cab252ee1821e87a4475e64818cf0eceb9, Previous: 764550ac612859709259b70e7b0145e9b5ec6469b2be288d24aa227eeeaf9fa0, Data: Transaction 3: Charlie -> Dave 1 BTC]
    Цепочка валидна: True
    
    Попытка изменения данных...
    Цепочка валидна после изменения: False
    Пересечение arr1 и arr2: False
    Пересечение arr1 и arr3: True
    Все элементы unique_arr уникальны: True
    Все элементы duplicate_arr уникальны: False
    Пары с суммой 9 в массиве [2, 7, 11, 15, 3, 6, 8]: [(2, 7), (3, 6)]
    'listen' и 'silent' являются анаграммами: True
    'hello' и 'world' являются анаграммами: False
    


```python
# Демонстрация работы всех структур

def demonstrate_all():
    print("ДЕМОНСТРАЦИЯ РАБОТЫ ВСЕХ СТРУКТУР\n")
    
    print("1. Хеш-таблица методом цепочек:")
    cht = ChainingHashTable(3)
    for i, fruit in enumerate(["apple", "banana", "orange", "grape", "kiwi"]):
        cht.put(fruit, i)
    print(cht)
    print()
    
    print("2. Хеш-таблица методом открытой адресации:")
    oaht = OpenAddressingHashTable(5)
    for i, color in enumerate(["red", "green", "blue", "yellow", "purple"]):
        oaht.put(color, i)
    print(oaht)
    print()
    
    print("3. Блокчейн:")
    bc = Blockchain()
    bc.add_block("Block 1 Data")
    bc.add_block("Block 2 Data")
    print(bc)
    print(f"Цепочка валидна: {bc.is_chain_valid()}")
    print()
    
    print("4. Проверка пересечения массивов:")
    print(f"[1,2,3] и [3,4,5]: {array_intersection([1,2,3], [3,4,5])}")
    print(f"[1,2,3] и [4,5,6]: {array_intersection([1,2,3], [4,5,6])}")
    print()
    
    print("5. Проверка уникальности:")
    print(f"[1,2,3,4,5]: {all_unique_elements([1,2,3,4,5])}")
    print(f"[1,2,3,2,4]: {all_unique_elements([1,2,3,2,4])}")
    print()
    
    print("6. Поиск пар с суммой:")
    arr = [1, 4, 2, 3, 5, 6]
    target = 7
    print(f"Пары с суммой {target} в {arr}: {find_pairs_with_sum(arr, target)}")
    print()
    print("7. Проверка анаграмм:")
    print(f"'listen' и 'silent': {are_anagrams('listen', 'silent')}")
    print(f"'hello' и 'world': {are_anagrams('hello', 'world')}")

demonstrate_all()
    
```

    ДЕМОНСТРАЦИЯ РАБОТЫ ВСЕХ СТРУКТУР
    
    1. Хеш-таблица методом цепочек:
    Bucket 0: (banana: 1) -> (orange: 2)
    Bucket 1: (apple: 0)
    Bucket 2: (kiwi: 4)
    Bucket 4: (grape: 3)
    
    2. Хеш-таблица методом открытой адресации:
    Index 0: (blue: 2)
    Index 1: (red: 0)
    Index 2: (yellow: 3)
    Index 3: (purple: 4)
    Index 4: None
    Index 5: None
    Index 6: None
    Index 7: None
    Index 8: None
    Index 9: (green: 1)
    
    3. Блокчейн:
    Block 0 [Hash: 0eb5535c8f65788499ffe9efbdc3b4d7b09b914139b5a845aa1c0ef50a159af1, Previous: 0, Data: Genesis Block]
    Block 1 [Hash: d0e4c69765efbb5508fc046ba0bcd3b5769aac9e6d47e1128a96489120db1f9d, Previous: 0eb5535c8f65788499ffe9efbdc3b4d7b09b914139b5a845aa1c0ef50a159af1, Data: Block 1 Data]
    Block 2 [Hash: c1fd071259e91e067250df16dceee69355c1f41441209b5c5842686684a356b0, Previous: d0e4c69765efbb5508fc046ba0bcd3b5769aac9e6d47e1128a96489120db1f9d, Data: Block 2 Data]
    Цепочка валидна: True
    
    4. Проверка пересечения массивов:
    [1,2,3] и [3,4,5]: True
    [1,2,3] и [4,5,6]: False
    
    5. Проверка уникальности:
    [1,2,3,4,5]: True
    [1,2,3,2,4]: False
    
    6. Поиск пар с суммой:
    Пары с суммой 7 в [1, 4, 2, 3, 5, 6]: [(4, 3), (2, 5), (1, 6)]
    
    7. Проверка анаграмм:
    'listen' и 'silent': True
    'hello' и 'world': False
    
