```python
# ============== 1. ЗАДАЧА О РЮКЗАКЕ С ДРОБНЫМИ ПРЕДМЕТАМИ ==============
def fractional_knapsack(items, capacity):
    """Задача о рюкзаке с возможностью брать части предметов"""
    sorted_items = sorted(items, key=lambda x: x.price / x.weight, reverse=True)
    total_value = 0
    remaining_capacity = capacity
    
    for item in sorted_items:
        if remaining_capacity >= item.weight:
            total_value += item.price
            remaining_capacity -= item.weight
        else:
            fraction = remaining_capacity / item.weight
            total_value += item.price * fraction
            break
    
    return total_value

# ============== 2. ЗАДАЧА О ПОКРЫТИИ ОТРЕЗКАМИ ==============
def interval_covering(intervals, target):
    """Минимальное количество отрезков, покрывающих целевой отрезок"""
    if not intervals:
        return 0
    
    # Сортируем по правому концу
    intervals.sort(key=lambda x: x[1])
    
    count = 0
    current_end = target[0]
    i = 0
    
    while current_end < target[1] and i < len(intervals):
        # Ищем отрезок, который начинается не позже current_end и имеет максимальный правый конец
        next_end = current_end
        while i < len(intervals) and intervals[i][0] <= current_end:
            next_end = max(next_end, intervals[i][1])
            i += 1
        
        if next_end == current_end:  # Не нашли подходящий отрезок
            return -1
        
        count += 1
        current_end = next_end
    
    return count if current_end >= target[1] else -1

# ============== 3. АЛГОРИТМ ФЛОЙДА-УОРШЕЛЛА ==============
def floyd_warshall(graph):
    """Нахождение кратчайших путей между всеми парами вершин"""
    n = len(graph)
    dist = [[float('inf')] * n for _ in range(n)]
    
    # Инициализация
    for i in range(n):
        dist[i][i] = 0
        for j, weight in enumerate(graph[i]):
            if weight != 0:
                dist[i][j] = weight
    
    # Алгоритм Флойда-Уоршелла
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    return dist

# ============== 4. ЗАДАЧА О РАЗМЕНЕ МОНЕТ (ДИНАМИЧЕСКОЕ ПРОГРАММИРОВАНИЕ) ==============
def coin_change_dp(coins, amount):
    """Минимальное количество монет для суммы (динамическое программирование)"""
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1

# ============== 5. ГЕНЕРАЦИЯ РАЗБИЕНИЙ МНОЖЕСТВА ==============
def set_partitions(elements):
    """Все возможные разбиения множества"""
    result = []
    
    def backtrack(index, current_partition):
        if index == len(elements):
            result.append([part[:] for part in current_partition])
            return
        
        # Добавляем элемент к существующим подмножествам
        for i in range(len(current_partition)):
            current_partition[i].append(elements[index])
            backtrack(index + 1, current_partition)
            current_partition[i].pop()
        
        # Создаем новое подмножество
        current_partition.append([elements[index]])
        backtrack(index + 1, current_partition)
        current_partition.pop()
    
    backtrack(0, [])
    return result

# ============== 6. ГЕНЕТИЧЕСКИЙ АЛГОРИТМ ДЛЯ МНОГОМЕРНОЙ ФУНКЦИИ ==============
import random
import math

def genetic_algorithm_multidimensional(dimensions, fitness_func, pop_size=50, generations=100):
    """Генетический алгоритм для оптимизации многомерной функции"""
    
    # Генерация начальной популяции
    def create_individual():
        return [random.uniform(-10, 10) for _ in range(dimensions)]
    
    population = [create_individual() for _ in range(pop_size)]
    
    for generation in range(generations):
        # Оценка приспособленности
        fitness_scores = [fitness_func(ind) for ind in population]
        
        # Селекция (турнирный отбор)
        selected = []
        for _ in range(pop_size):
            tournament = random.sample(list(enumerate(population)), 3)
            winner = max(tournament, key=lambda x: fitness_scores[x[0]])
            selected.append(winner[1])
        
        # Кроссовер (одноточечный)
        new_population = []
        for i in range(0, pop_size, 2):
            parent1 = selected[i]
            parent2 = selected[i + 1]
            point = random.randint(1, dimensions - 1)
            child1 = parent1[:point] + parent2[point:]
            child2 = parent2[:point] + parent1[point:]
            new_population.extend([child1, child2])
        
        # Мутация
        for i in range(pop_size):
            if random.random() < 0.1:  # 10% вероятность мутации
                idx = random.randint(0, dimensions - 1)
                new_population[i][idx] += random.gauss(0, 1)
        
        population = new_population
    
    # Находим лучшую особь
    best_index = max(range(pop_size), key=lambda i: fitness_func(population[i]))
    return population[best_index]

# ============== КЛАСС ДЛЯ ТЕСТИРОВАНИЯ ==============
class Item:
    def __init__(self, price, weight):
        self.price = price
        self.weight = weight

# ============== ТЕСТЫ И ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ ==============
def main():
    print("=== РЕАЛИЗАЦИЯ АЛГОРИТМОВ ИЗ ЛЕКЦИИ 14 ===\n")
    
    # 1. Тест задачи о рюкзаке с дробными предметами
    print("1. Задача о рюкзаке с дробными предметами:")
    items = [Item(60, 10), Item(100, 20), Item(120, 30)]
    result = fractional_knapsack(items, 50)
    print(f"Максимальная стоимость: {result}")
    
    # 2. Тест задачи о покрытии отрезками
    print("\n2. Задача о покрытии отрезками:")
    intervals = [(1, 4), (2, 5), (3, 6), (5, 7), (6, 8)]
    target = (2, 7)
    result = interval_covering(intervals, target)
    print(f"Минимальное количество отрезков: {result}")
    
    # 3. Тест алгоритма Флойда-Уоршелла
    print("\n3. Алгоритм Флойда-Уоршелла:")
    graph = [
        [0, 3, 0, 5],
        [2, 0, 0, 4],
        [0, 1, 0, 0],
        [0, 0, 2, 0]
    ]
    result = floyd_warshall(graph)
    print("Матрица кратчайших расстояний:")
    for row in result:
        print(row)
    
    # 4. Тест задачи о размене монет
    print("\n4. Задача о размене монет (ДП):")
    coins = [1, 2, 5]
    amount = 11
    result = coin_change_dp(coins, amount)
    print(f"Минимальное количество монет для суммы {amount}: {result}")
    
    # 5. Тест генерации разбиений множества
    print("\n5. Генерация разбиений множества:")
    elements = [1, 2, 3]
    result = set_partitions(elements)
    print(f"Все разбиения множества {elements}:")
    for i, partition in enumerate(result):
        print(f"  {i+1}. {partition}")
    
    # 6. Тест генетического алгоритма для многомерной функции
    print("\n6. Генетический алгоритм для многомерной функции:")
    
    # Пример: минимизация суммы квадратов (сфера)
    def sphere_function(x):
        return -sum(xi**2 for xi in x)  # Отрицательное для максимизации
    
    result = genetic_algorithm_multidimensional(3, sphere_function)
    print(f"Лучшее решение: {result}")
    print(f"Значение функции: {sphere_function(result)}")

if __name__ == "__main__":
    main()
```

    === РЕАЛИЗАЦИЯ АЛГОРИТМОВ ИЗ ЛЕКЦИИ 14 ===
    
    1. Задача о рюкзаке с дробными предметами:
    Максимальная стоимость: 240.0
    
    2. Задача о покрытии отрезками:
    Минимальное количество отрезков: 2
    
    3. Алгоритм Флойда-Уоршелла:
    Матрица кратчайших расстояний:
    [0, 3, 7, 5]
    [2, 0, 6, 4]
    [3, 1, 0, 5]
    [5, 3, 2, 0]
    
    4. Задача о размене монет (ДП):
    Минимальное количество монет для суммы 11: 3
    
    5. Генерация разбиений множества:
    Все разбиения множества [1, 2, 3]:
      1. [[1, 2, 3]]
      2. [[1, 2], [3]]
      3. [[1, 3], [2]]
      4. [[1], [2, 3]]
      5. [[1], [2], [3]]
    
    6. Генетический алгоритм для многомерной функции:
    Лучшее решение: [-0.016462005504546892, -0.005191040999760234, 0.014703245057232028]
    Значение функции: -0.000514129947105942
    
