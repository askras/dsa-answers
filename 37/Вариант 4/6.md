# Итеративные и рекурсивные алгоритмы

Ломовский Е.М. ИУ10-37

### Задание 1: Рекурсивные алгоритмы (Вариант 4)

```python
def nested_roots_recursive(m, n):
    if n == 1:
        return m ** 0.5
    return (m + nested_roots_recursive(m, n-1)) ** 0.5

print(f"m=2, n=3: {nested_roots_recursive(2, 3):.4f}")
print(f"m=5, n=4: {nested_roots_recursive(5, 4):.4f}")
print(f"m=10, n=5: {nested_roots_recursive(10, 5):.4f}")
```

### Задание 2: Итеративные алгоритмы

```python
def nested_roots_iterative(m, n):
    if m < 0:
        raise ValueError("m должно быть неотрицательным")
    if n < 1:
        raise ValueError("n должно быть положительным")
    
    result = m ** 0.5
    for i in range(2, n + 1):
        result = (m + result) ** 0.5
    return result

print(f"m=2, n=3: {nested_roots_iterative(2, 3):.4f}")
print(f"m=5, n=4: {nested_roots_iterative(5, 4):.4f}")
print(f"m=10, n=5: {nested_roots_iterative(10, 5):.4f}")
```

### Задание 3: Анализ и сравнение алгоритмов

#### 3.1 Блок-схема рекурсивного алгоритма

    ┌─────────────────┐
    │   НАЧАЛО        │
    │ nested_roots(m,n)│
    └─────────┬───────┘
              │
              ▼
    ┌─────────────────┐
    │    n == 1 ?     │ ←─┐
    └─────────┬───────┘   │
              │             │
        ┌─────┴─────┐       │
        ▼           ▼       │
    ┌─────────┐ ┌─────────┐ │
    │ YES:    │ │ NO:     │ │
    │ return√m│ │ recursive│ │
    └─────────┘ │ = ...    │ │
                └─────┬─────┘ │
                      ▼       │
                ┌─────────┐   │
                │ return  │   │
                │ √(m+rec)│   │
                └─────────┘   │
                      │       │
                      └───────┘

### 3.2 Оценка верхней границы глубины рекурсии

```python
def analyze_recursion_depth():
    print("АНАЛИЗ ГЛУБИНЫ РЕКУРСИИ")
    def nested_roots_recursive(m, n):
        if n == 1:
            return m ** 0.5
        return (m + nested_roots_recursive(m, n-1)) ** 0.5
    
    recursion_limit = sys.getrecursionlimit()
    print(f"Текущий лимит рекурсии в Python: {recursion_limit}")
    
    m = 2
    max_safe_depth = 0
    test_depths = [100, 500, 800, 900, 950, 980, 990]
    
    print("\nТестирование глубины рекурсии:")
    for n in test_depths:
        try:
            result = nested_roots_recursive(m, n)
            max_safe_depth = n
            print(f"n={n}: успешно, результат = {result:.6f}")
        except RecursionError:
            print(f"n={n}: переполнение стека")
            break
    print(f"\nРЕЗУЛЬТАТЫ АНАЛИЗА:")
    print(f"  - Максимальная безопасная глубина: {max_safe_depth}")
    print(f"  - Рекомендуемый предел: {max_safe_depth - 50}")
    print(f"  - Запас безопасности: ~{recursion_limit - max_safe_depth} вызовов")
    
    return max_safe_depth

max_depth = analyze_recursion_depth()
```

АНАЛИЗ ГЛУБИНЫ РЕКУРСИИ
Текущий лимит рекурсии в Python: 1000

Тестирование глубины рекурсии:

  n=100: успешно, результат = 2.000000
  
  n=500: успешно, результат = 2.000000
  
  n=800: успешно, результат = 2.000000
  
  n=900: переполнение стека
  

РЕЗУЛЬТАТЫ АНАЛИЗА:

  - Максимальная безопасная глубина: 800
  - Рекомендуемый предел: 750
  - Запас безопасности: ~200 вызовов

### Задание 3.3 Модернизация с сохранением промежуточных результатов

```python
def nested_roots_manual_memo(m, n, memo=None):
    if memo is None:
        memo = {}
    
    if (m, n) in memo:
        return memo[(m, n)]
    
    if n == 1:
        result = m ** 0.5
        memo[(m, n)] = result
        return result
    
    recursive_result = nested_roots_manual_memo(m, n-1, memo)
    result = (m + recursive_result) ** 0.5
    memo[(m, n)] = result
    
    return result

def memoize_decorator(func):
    cache = {}
    
    @wraps(func)
    def wrapper(m, n):
        key = (m, n)
        if key not in cache:
            cache[key] = func(m, n)
        return cache[key]
    
    return wrapper

@memoize_decorator
def nested_roots_decorated(m, n):
    if n == 1:
        return m ** 0.5
    return (m + nested_roots_decorated(m, n-1)) ** 0.5

def nested_roots_iterative(m, n):
    if n < 1:
        raise ValueError("n должно быть положительным")
    
    result = m ** 0.5
    for i in range(2, n + 1):
        result = (m + result) ** 0.5
    return result

m, n = 2, 100

start = time.time()
result_base = nested_roots_recursive(m, 20)
time_base = time.time() - start

start = time.time()
result_manual = nested_roots_manual_memo(m, n)
time_manual = time.time() - start

start = time.time()
result_decorated = nested_roots_decorated(m, n)
time_decorated = time.time() - start

start = time.time()
result_iterative = nested_roots_iterative(m, n)
time_iterative = time.time() - start

print(f"Базовая рекурсия (n=20): {time_base:.6f} сек")
print(f"Ручная мемоизация: {time_manual:.6f} сек")
print(f"Декоратор мемоизации: {time_decorated:.6f} сек")
print(f"Итеративная версия: {time_iterative:.6f} сек")

tolerance = 1e-10
results_match = (abs(result_manual - result_decorated) < tolerance and 
                abs(result_manual - result_iterative) < tolerance)
print(f"\nРезультаты совпадают: {results_match}")
```

Базовая рекурсия (n=20): 0.000187 сек

Ручная мемоизация:       0.000034 сек

Декоратор мемоизации:    0.000029 сек

Итеративная версия:      0.000015 сек 

Результаты совпадают: True

### Залание 3.4 Сравнение производительности алгоритмов

```python
def compare_algorithms_performance():
    test_cases = [
        (2, 10, "Маленькая"),
        (2, 100, "Средняя"), 
        (2, 500, "Большая"),
        (5, 100, "Разные m")
    ]
    
    results = []
    
    for m, n, complexity in test_cases:
        print(f"\nТест: m={m}, n={n} ({complexity} сложность)")
        
        times = {}
        
        start = time.time()
        result_iter = nested_roots_iterative(m, n)
        times['iterative'] = time.time() - start
        
        start = time.time()
        result_manual = nested_roots_manual_memo(m, n)
        times['manual_memo'] = time.time() - start
        
        start = time.time()
        result_decor = nested_roots_decorated(m, n)
        times['decorator_memo'] = time.time() - start
        
        if n <= 50:
            start = time.time()
            result_base = nested_roots_recursive(m, n)
            times['base_recursive'] = time.time() - start
        else:
            times['base_recursive'] = None
        
        print(f"Итеративная: {times['iterative']:.6f} сек")
        print(f"Ручная мемоизация: {times['manual_memo']:.6f} сек")
        print(f"Декоратор мемоизации: {times['decorator_memo']:.6f} сек")
        if times['base_recursive'] is not None:
            print(f"Базовая рекурсия: {times['base_recursive']:.6f} сек")
        
        tolerance = 1e-10
        if (abs(result_iter - result_manual) < tolerance and 
            abs(result_iter - result_decor) < tolerance):
            print("Результаты совпадают")
        else:
            print("Результаты различаются")
        
        results.append({
            'm': m, 'n': n, 'complexity': complexity,
            'times': times,
            'result': result_iter
        })
    
    return results
```

Тест: m=2, n=10 (Маленькая сложность)

  Итеративная:        0.000012 сек
  
  Ручная мемоизация:  0.000022 сек
  
  Декоратор мемоизации: 0.000019 сек
  
  Базовая рекурсия:   0.000045 сек
  
  Результаты совпадают





