# Алгоритмы на графах

Ломовский Е.м. ИУ10-37

### Задание 1

```python
from collections import deque
import heapq

class Graph:
    def __init__(self, directed=False):
        self.graph = {}
        self.directed = directed
    
    def add_vertex(self, vertex):
        if vertex not in self.graph:
            self.graph[vertex] = {}
    
    def add_edge(self, u, v, weight=1):
        self.add_vertex(u)
        self.add_vertex(v)
        self.graph[u][v] = weight
        if not self.directed:
            self.graph[v][u] = weight
    
    def get_vertices(self):
        return list(self.graph.keys())
    
    def get_edges(self):
        edges = []
        for u in self.graph:
            for v, weight in self.graph[u].items():
                edges.append((u, v, weight))
        return edges
    
    def __str__(self):
        result = []
        for vertex in sorted(self.graph.keys()):
            neighbors = []
            for neighbor, weight in sorted(self.graph[vertex].items()):
                neighbors.append(f"{neighbor}({weight})")
            result.append(f"{vertex}: {', '.join(neighbors)}")
        return "\n".join(result)
```
### Задание 2

```python
class GraphApp:
    def __init__(self):
        self.graph = Graph(directed=True)
        self.initialize_graph()
    
    def initialize_graph(self):
        """Инициализация графа из варианта 4"""
        edges = [(4, 3, 8), (4, 1, 2), (1, 2, 4), (2, 3, 10), (3, 1, 1),
                (1, 5, 15), (5, 9, 1), (9, 6, 6), (6, 7, 7), (7, 8, 8)]
        for u, v, w in edges:
            self.graph.add_edge(u, v, w)
    
    def show_menu(self):
        print("\n" + "="*50)
        print("ГРАФОВЫЙ КАЛЬКУЛЯТОР")
        print("="*50)
        print("1. Показать граф")
        print("2. Поиск в глубину (DFS)")
        print("3. Поиск в ширину (BFS)")
        print("4. Алгоритм Дейкстры")
        print("5. Кратчайший путь (Задание 4)")
        print("6. Добавить вершину")
        print("7. Добавить ребро")
        print("0. Выход")
    
    def run(self):
        while True:
            self.show_menu()
            choice = input("Выберите действие: ").strip()
            
            if choice == '1':
                self.show_graph()
            elif choice == '2':
                self.dfs_search()
            elif choice == '3':
                self.bfs_search()
            elif choice == '4':
                self.dijkstra_search()
            elif choice == '5':
                self.task4_shortest_path()
            elif choice == '6':
                self.add_vertex()
            elif choice == '7':
                self.add_edge()
            elif choice == '0':
                print("Выход из программы.")
                break
            else:
                print("Неверный выбор!")
    
    def show_graph(self):
        print("\nТЕКУЩИЙ ГРАФ:")
        print(self.graph)
    
    def dfs_search(self):
        start = int(input("Введите начальную вершину для DFS: "))
        visited = set()
        result = []
        
        def dfs(v):
            visited.add(v)
            result.append(v)
            for neighbor in sorted(self.graph.graph.get(v, {}).keys()):
                if neighbor not in visited:
                    dfs(neighbor)
        
        if start in self.graph.graph:
            dfs(start)
            print(f"DFS от вершины {start}: {result}")
        else:
            print("Вершина не найдена!")
    
    def bfs_search(self):
        start = int(input("Введите начальную вершину для BFS: "))
        if start not in self.graph.graph:
            print("Вершина не найдена!")
            return
        
        visited = set()
        queue = deque([start])
        result = []
        
        while queue:
            vertex = queue.popleft()
            if vertex not in visited:
                visited.add(vertex)
                result.append(vertex)
                for neighbor in sorted(self.graph.graph[vertex].keys()):
                    if neighbor not in visited:
                        queue.append(neighbor)
        
        print(f"BFS от вершины {start}: {result}")
    
    def dijkstra_search(self):
        start = int(input("Введите начальную вершину: "))
        if start not in self.graph.graph:
            print("Вершина не найдена!")
            return
        
        distances = {vertex: float('inf') for vertex in self.graph.graph}
        distances[start] = 0
        pq = [(0, start)]
        
        while pq:
            current_dist, current_vertex = heapq.heappop(pq)
            
            if current_dist > distances[current_vertex]:
                continue
            
            for neighbor, weight in self.graph.graph[current_vertex].items():
                distance = current_dist + weight
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(pq, (distance, neighbor))
        
        print(f"\nКратчайшие расстояния от вершина {start}:")
        for vertex in sorted(distances.keys()):
            dist = distances[vertex]
            print(f"  до {vertex}: {dist if dist != float('inf') else '∞'}")
    
    def task4_shortest_path(self):
        """Кратчайший путь между вершинами 1 и 7 (Задание 4)"""
        start, end = 1, 7
        print(f"\nПоиск кратчайшего пути от {start} до {end}")
        
        distances = {vertex: float('inf') for vertex in self.graph.graph}
        distances[start] = 0
        previous = {vertex: None for vertex in self.graph.graph}
        pq = [(0, start)]
        
        while pq:
            current_dist, current_vertex = heapq.heappop(pq)
            
            if current_vertex == end:
                break
                
            if current_dist > distances[current_vertex]:
                continue
            
            for neighbor, weight in self.graph.graph[current_vertex].items():
                distance = current_dist + weight
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current_vertex
                    heapq.heappush(pq, (distance, neighbor))
        
        path = []
        current = end
        while current is not None:
            path.append(current)
            current = previous[current]
        path.reverse()
        
        if path[0] == start:
            print(f"Кратчайший путь: {' -> '.join(map(str, path))}")
            print(f"Длина пути: {distances[end]}")
        else:
            print("Путь не найден!")
    
    def add_vertex(self):
        vertex = int(input("Введите номер новой вершины: "))
        self.graph.add_vertex(vertex)
        print(f"Вершина {vertex} добавлена.")
    
    def add_edge(self):
        u = int(input("Введите начальную вершину: "))
        v = int(input("Введите конечную вершину: "))
        w = int(input("Введите вес ребра: "))
        self.graph.add_edge(u, v, w)
        print(f"Ребро {u} -> {v} (вес {w}) добавлено.")

print("Запуск диалогового приложения...")
app = GraphApp()
# app.run()
```
### Задание 4

```python
def find_shortest_path_1_7():
    g = Graph(directed=True)
    edges = [(4, 3, 8), (4, 1, 2), (1, 2, 4), (2, 3, 10), (3, 1, 1),
            (1, 5, 15), (5, 9, 1), (9, 6, 6), (6, 7, 7), (7, 8, 8)]
    
    for u, v, w in edges:
        g.add_edge(u, v, w)
    
    start, end = 1, 7
    
    distances = {vertex: float('inf') for vertex in g.graph}
    distances[start] = 0
    previous = {vertex: None for vertex in g.graph}
    pq = [(0, start)]
    
    while pq:
        current_dist, current_vertex = heapq.heappop(pq)
        
        if current_vertex == end:
            break
            
        if current_dist > distances[current_vertex]:
            continue
        
        for neighbor, weight in g.graph[current_vertex].items():
            distance = current_dist + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous[neighbor] = current_vertex
                heapq.heappush(pq, (distance, neighbor))
    
    path = []
    current = end
    while current is not None:
        path.append(current)
        current = previous[current]
    path.reverse()
    
    print("ЗАДАНИЕ 4: Кратчайший путь от 1 до 7")
    print("=" * 40)
    print(f"Граф: {g}")
    print(f"\nРезультат:")
    if path[0] == start:
        print(f"Кратчайший путь: {' -> '.join(map(str, path))}")
        print(f"Длина пути: {distances[end]}")
    else:
        print("Путь не найден!")

find_shortest_path_1_7()
```
### Задание 5

```python
def dijkstra_task5():
    g = Graph(directed=True)
    edges = [(9, 2, 12), (2, 16, 1), (16, 19, 6), (1, 6, 28), 
            (6, 5, 3), (5, 3, 7), (2, 3, 15), (3, 25, 2),
            (10, 6, 1)]
    
    for u, v, w in edges:
        g.add_edge(u, v, w)
    
    start, end = 3, 8
    
    distances = {vertex: float('inf') for vertex in g.graph}
    distances[start] = 0
    previous = {vertex: None for vertex in g.graph}
    pq = [(0, start)]
    
    while pq:
        current_dist, current_vertex = heapq.heappop(pq)
        
        if current_vertex == end:
            break
            
        if current_dist > distances[current_vertex]:
            continue
        
        for neighbor, weight in g.graph[current_vertex].items():
            distance = current_dist + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous[neighbor] = current_vertex
                heapq.heappush(pq, (distance, neighbor))
    
    path = []
    current = end
    while current is not None:
        path.append(current)
        current = previous[current]
    path.reverse()
    
    print("ЗАДАНИЕ 5: Алгоритм Дейкстры (3 -> 8)")
    print("=" * 40)
    print(f"Граф: {g}")
    print(f"\nРезультат:")
    if path and path[0] == start:
        print(f"Кратчайший путь: {' -> '.join(map(str, path))}")
        print(f"Длина пути: {distances[end]}")
    else:
        print("Путь не найден!")

dijkstra_task5()
```
### Задание 6

```python
def bfs_shortest_path():
    g = Graph(directed=True)
    edges = [(4, 3, 1), (4, 1, 1), (1, 2, 1), (2, 3, 1), (3, 1, 1),
            (1, 5, 1), (5, 9, 1), (9, 6, 1), (6, 7, 1), (7, 8, 1)]
    
    for u, v, w in edges:
        g.add_edge(u, v, w)
    
    start, end = 1, 7
    
    visited = set()
    queue = deque([(start, [start])])
    
    while queue:
        current_vertex, path = queue.popleft()
        
        if current_vertex == end:
            print("ЗАДАНИЕ 6: BFS поиск кратчайшего пути")
            print("=" * 40)
            print(f"Кратчайший путь: {' -> '.join(map(str, path))}")
            print(f"Длина пути: {len(path) - 1}")
            return
        
        if current_vertex not in visited:
            visited.add(current_vertex)
            for neighbor in g.graph[current_vertex]:
                if neighbor not in visited:
                    queue.append((neighbor, path + [neighbor]))
    
    print("Путь не найден!")

bfs_shortest_path()
