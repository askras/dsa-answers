# Notebook

# Криптоалгоритмы

Ломовский Егор ИУ10-37

### Задание 1 (Вариант 4)

```python
import random
import math
from sympy import isprime, nextprime
import hashlib

class BookCipher:
    
    def __init__(self, key_book=None):
        self.key_book = key_book or self._get_default_book()
    
    def _get_default_book(self):
        #Возвращает книгу по умолчанию (Война и Мир)
        return [
            "Война и мир есть совокупность всех сознательно производимых людьми поступков."
        ]
    
    def _text_to_numbers(self, text):
        return [ord(char) for char in text]
    
    def _numbers_to_text(self, numbers):
        return ''.join(chr(num) for num in numbers if num < 1114112)
    
    def _generate_key_from_string(self, key_string, length):
        key_hash = hashlib.sha256(key_string.encode()).hexdigest()
        key_numbers = []
        
        for i in range(length):
            byte_val = int(key_hash[i % 64], 16)
            key_numbers.append(byte_val)
        
        return key_numbers
    
    def encrypt(self, plaintext, key_string):
        if not plaintext:
            return ""
        
        text_numbers = self._text_to_numbers(plaintext)
        
        key = self._generate_key_from_string(key_string, len(text_numbers))
        
        encrypted_numbers = []
        book_positions = []
        
        for i, (char_num, key_val) in enumerate(zip(text_numbers, key)):
            book_line_idx = key_val % len(self.key_book)
            book_line = self.key_book[book_line_idx]

            char_pos = (char_num + key_val) % len(book_line)

            encrypted_char = book_line[char_pos]
            encrypted_numbers.append(ord(encrypted_char))
            book_positions.append((book_line_idx, char_pos))

        encrypted_text = self._numbers_to_text(encrypted_numbers)
        return encrypted_text, book_positions
    
    def decrypt(self, ciphertext, key_string, book_positions):
        if not ciphertext:
            return ""

        cipher_numbers = self._text_to_numbers(ciphertext)

        key = self._generate_key_from_string(key_string, len(cipher_numbers))

        decrypted_numbers = []
        
        for i, (cipher_num, key_val, (book_line_idx, char_pos)) in enumerate(zip(cipher_numbers, key, book_positions)):
            book_line = self.key_book[book_line_idx]
            
            original_char_num = (ord(book_line[char_pos]) - key_val) % 1114112
            decrypted_numbers.append(original_char_num)
        
        return self._numbers_to_text(decrypted_numbers)

class GoldwasserMicali:
    
    def __init__(self, bit_length=64):
        self.bit_length = bit_length
        self.p = None
        self.q = None
        self.n = None
        self.y = None
    
    def generate_keys(self):
        half_bits = self.bit_length // 2
        
        while True:
            p_candidate = nextprime(random.getrandbits(half_bits))
            if p_candidate % 4 == 3:
                self.p = p_candidate
                break
        
        while True:
            q_candidate = nextprime(random.getrandbits(half_bits))
            if q_candidate % 4 == 3 and q_candidate != self.p:
                self.q = q_candidate
                break
        
        self.n = self.p * self.q
        
        while True:
            y_candidate = random.randint(2, self.n - 1)
            if self._jacobi_symbol(y_candidate, self.p) == -1 and self._jacobi_symbol(y_candidate, self.q) == -1:
                self.y = y_candidate
                break
        
        public_key = (self.n, self.y)
        private_key = (self.p, self.q)
        
        return public_key, private_key
    
    def _jacobi_symbol(self, a, n):
        if n <= 0 or n % 2 == 0:
            return 0
        
        result = 1
        if a < 0:
            a = -a
            if n % 4 == 3:
                result = -result
        
        while a != 0:
            while a % 2 == 0:
                a //= 2
                if n % 8 == 3 or n % 8 == 5:
                    result = -result
            
            a, n = n, a
            if a % 4 == 3 and n % 4 == 3:
                result = -result
            a %= n
        
        return result if n == 1 else 0
    
    def _is_quadratic_residue(self, x, p):
        return pow(x, (p - 1) // 2, p) == 1
    
    def encrypt_bit(self, public_key, bit):
        n, y = public_key
        
        r = random.randint(1, n - 1)
        
        if bit == 0:
            ciphertext = pow(r, 2, n)
        else:
            ciphertext = (pow(r, 2, n) * y) % n
        
        return ciphertext
    
    def decrypt_bit(self, private_key, ciphertext):

        p, q = private_key

        if self._is_quadratic_residue(ciphertext, p):
            return 0
        else:
            return 1 
    
    def encrypt_message(self, public_key, message):

        binary_message = ''.join(format(ord(char), '08b') for char in message)
        
        ciphertext = []
        for bit in binary_message:
            encrypted_bit = self.encrypt_bit(public_key, int(bit))
            ciphertext.append(encrypted_bit)
        
        return ciphertext
    
    def decrypt_message(self, private_key, ciphertext):

        binary_message = ''
        for encrypted_bit in ciphertext:
            decrypted_bit = self.decrypt_bit(private_key, encrypted_bit)
            binary_message += str(decrypted_bit)
        
        message = ''
        for i in range(0, len(binary_message), 8):
            byte = binary_message[i:i+8]
            if len(byte) == 8:
                message += chr(int(byte, 2))
        
        return message

def demonstrate_book_cipher():
    
    book_cipher = BookCipher()
    
    plaintext = "Секретное сообщение для шифрования!"
    key = "фф12К52"
    
    print(f"Исходный текст: {plaintext}")
    print(f"Ключ: {key}")
    
    ciphertext, positions = book_cipher.encrypt(plaintext, key)
    print(f"Зашифрованный текст: {ciphertext}")
    print(f"Позиции в книге: {positions[:5]}...")
    
    decrypted_text = book_cipher.decrypt(ciphertext, key, positions)
    print(f"Дешифрованный текст: {decrypted_text}")

    print(f"Тексты идентичны: {plaintext == decrypted_text}")
    print()

def demonstrate_goldwasser_micali():
    
    gm = GoldwasserMicali(bit_length=128)
    
    public_key, private_key = gm.generate_keys()
    print("Ключи сгенерированы:")
    print(f"Публичный ключ (n, y): ({public_key[0]}, {public_key[1]})")
    print(f"Приватный ключ (p, q): ({private_key[0]}, {private_key[1]})")
    print()
    
def performance_comparison():

    import time
    
    test_message = "Тестовое сообщение для сравнения производительности криптоалгоритмов."
    key = "фф12К52"

    print("Книжный шифр:")
    print(f"  Шифрование: {book_encrypt_time:.4f} сек")
    print(f"  Дешифрование: {book_decrypt_time:.4f} сек")
    print(f"  Всего: {book_encrypt_time + book_decrypt_time:.4f} сек")
    print(f"  Корректность: {test_message == decrypted}")
    
    print("\nГольдвассер-Микали:")
    print(f"  Шифрование: {gm_encrypt_time:.4f} сек")
    print(f"  Дешифрование: {gm_decrypt_time:.4f} сек")
    print(f"  Всего: {gm_encrypt_time + gm_decrypt_time:.4f} сек")
    print(f"  Корректность: {test_message == gm_decrypted}")
    
    print(f"\nОтношение скоростей (Книжный/ГМ): {(book_encrypt_time + book_decrypt_time) / (gm_encrypt_time + gm_decrypt_time):.2f}x")
```


