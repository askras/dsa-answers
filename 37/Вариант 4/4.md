# Лабораторная работа: Стек, Очередь, Дек
ИУ10-37 Ломовский Е.М. 

### Задание 1

#### 1.1

```python
class ArrayStack:
    def __init__(self):
        self._items = []
    
    def push(self, item):
        self._items.append(item)
    
    def pop(self):
        if self.is_empty():
            raise Exception("Stack is empty")
        return self._items.pop()
    
    def peek(self):
        if self.is_empty():
            raise Exception("Stack is empty")
        return self._items[-1]
    
    def is_empty(self):
        return len(self._items) == 0
    
    def size(self):
        return len(self._items)
    
    def __str__(self):
        return str(self._items)
```
#### 1.2
``` python
class ArrayStack:
    def __init__(self):
        self._items = []
    
    def push(self, item):
        self._items.append(item)
    
    def pop(self):
        if self.is_empty():
            raise Exception("Stack is empty")
        return self._items.pop()
    
    def peek(self):
        if self.is_empty():
            raise Exception("Stack is empty")
        return self._items[-1]
    
    def is_empty(self):
        return len(self._items) == 0
    
    def size(self):
        return len(self._items)
    
    def __str__(self):
        return str(self._items)
```
#### 1.3
``` python
class LinkedListStack:
    def __init__(self):
        self.head = None
        self._size = 0
    
    def push(self, item):
        new_node = Node(item)
        new_node.next = self.head
        self.head = new_node
        self._size += 1
    
    def pop(self):
        if self.is_empty():
            raise Exception("Stack is empty")
        data = self.head.data
        self.head = self.head.next
        self._size -= 1
        return data
    
    def peek(self):
        if self.is_empty():
            raise Exception("Stack is empty")
        return self.head.data
    
    def is_empty(self):
        return self.head is None
    
    def size(self):
        return self._size
    
    def __str__(self):
        items = []
        current = self.head
        while current:
            items.append(current.data)
            current = current.next
        return str(items[::-1])
```
#### 1.4
``` python
class ArrayQueue:
    def __init__(self):
        self._items = []
    
    def enqueue(self, item):
        self._items.append(item)
    
    def dequeue(self):
        if self.is_empty():
            raise Exception("Queue is empty")
        return self._items.pop(0)
    
    def peek(self):
        if self.is_empty():
            raise Exception("Queue is empty")
        return self._items[0]
    
    def is_empty(self):
        return len(self._items) == 0
    
    def size(self):
        return len(self._items)
    
    def __str__(self):
        return str(self._items)
```
#### 1.5
``` python
class LinkedListQueue:
    def __init__(self):
        self.head = None
        self.tail = None
        self._size = 0
    
    def enqueue(self, item):
        new_node = Node(item)
        if self.is_empty():
            self.head = self.tail = new_node
        else:
            self.tail.next = new_node
            self.tail = new_node
        self._size += 1
    
    def dequeue(self):
        if self.is_empty():
            raise Exception("Queue is empty")
        data = self.head.data
        self.head = self.head.next
        if self.head is None:
            self.tail = None
        self._size -= 1
        return data
    
    def peek(self):
        if self.is_empty():
            raise Exception("Queue is empty")
        return self.head.data
    
    def is_empty(self):
        return self.head is None
    
    def size(self):
        return self._size
    
    def __str__(self):
        items = []
        current = self.head
        while current:
            items.append(current.data)
            current = current.next
        return str(items)
```
#### 1.6
``` python
class ArrayDeque:
    def __init__(self):
        self._items = []
    
    def push_front(self, item):
        self._items.insert(0, item)
    
    def push_back(self, item):
        self._items.append(item)
    
    def pop_front(self):
        if self.is_empty():
            raise Exception("Deque is empty")
        return self._items.pop(0)
    
    def pop_back(self):
        if self.is_empty():
            raise Exception("Deque is empty")
        return self._items.pop()
    
    def peek_front(self):
        if self.is_empty():
            raise Exception("Deque is empty")
        return self._items[0]
    
    def peek_back(self):
        if self.is_empty():
            raise Exception("Deque is empty")
        return self._items[-1]
    
    def is_empty(self):
        return len(self._items) == 0
    
    def size(self):
        return len(self._items)
    
    def __str__(self):
        return str(self._items)
```
#### 1.7
``` python
class LinkedListDeque:
    def __init__(self):
        self.head = None
        self.tail = None
        self._size = 0
    
    def push_front(self, item):
        new_node = DoublyNode(item)
        if self.is_empty():
            self.head = self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node
        self._size += 1
    
    def push_back(self, item):
        new_node = DoublyNode(item)
        if self.is_empty():
            self.head = self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node
        self._size += 1
    
    def pop_front(self):
        if self.is_empty():
            raise Exception("Deque is empty")
        data = self.head.data
        if self.head == self.tail:
            self.head = self.tail = None
        else:
            self.head = self.head.next
            self.head.prev = None
        self._size -= 1
        return data
    
    def pop_back(self):
        if self.is_empty():
            raise Exception("Deque is empty")
        data = self.tail.data
        if self.head == self.tail:
            self.head = self.tail = None
        else:
            self.tail = self.tail.prev
            self.tail.next = None
        self._size -= 1
        return data
    
    def peek_front(self):
        if self.is_empty():
            raise Exception("Deque is empty")
        return self.head.data
    
    def peek_back(self):
        if self.is_empty():
            raise Exception("Deque is empty")
        return self.tail.data
    
    def is_empty(self):
        return self.head is None
    
    def size(self):
        return self._size
    
    def __str__(self):
        items = []
        current = self.head
        while current:
            items.append(current.data)
            current = current.next
        return str(items)
```
#### 2
``` python
def check_brackets(expression):
    stack = ArrayStack()
    brackets = {')': '(', ']': '[', '}': '{'}
    
    for char in expression:
        if char in '([{':
            stack.push(char)
        elif char in ')]}':
            if stack.is_empty():
                return False
            if stack.pop() != brackets[char]:
                return False
    
    return stack.is_empty()
```
#### 3
``` python
def evaluate_postfix(expression):
    stack = ArrayStack()
    operators = {
        '+': lambda x, y: x + y,
        '-': lambda x, y: x - y,
        '*': lambda x, y: x * y,
        '/': lambda x, y: x / y
    }
    
    for token in expression.split():
        if token.isdigit():
            stack.push(int(token))
        elif token in operators:
            if stack.size() < 2:
                raise Exception("Недостаточно операндов")
            y = stack.pop()
            x = stack.pop()
            result = operators[token](x, y)
            stack.push(result)
        else:
            raise Exception(f"Неизвестный токен: {token}")
    
    if stack.size() != 1:
        raise Exception("Некорректное выражение")
    
    return stack.pop()
```
#### 4
``` python
def infix_to_postfix(expression):
    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}
    stack = ArrayStack()
    output = []
    
    for token in expression.split():
        if token.isdigit() or token.isalpha():
            output.append(token)
        elif token == '(':
            stack.push(token)
        elif token == ')':
            while not stack.is_empty() and stack.peek() != '(':
                output.append(stack.pop())
            stack.pop()  # Удаляем '('
        else:  # Оператор
            while (not stack.is_empty() and 
                   stack.peek() != '(' and 
                   precedence.get(stack.peek(), 0) >= precedence.get(token, 0)):
                output.append(stack.pop())
            stack.push(token)
    
    while not stack.is_empty():
        output.append(stack.pop())
    
    return ' '.join(output)
