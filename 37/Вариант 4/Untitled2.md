# Алгоритмы сортировки

Иу10-37
Ломовский Егор

## Задания

## Задание 1

| Алгоритм                                         | Устойчивость                                           | Место хранения       | На месте?   | Адаптивность        | Сложность (лучший / средний / худший)               |
| ------------------------------------------------ | ------------------------------------------------------ | -------------------- | ----------- | ------------------- | --------------------------------------------------- |
| **Bitonic sort (Битонная)**                      | Неустойчивая                                           | Внутренняя           | Частично    | Неадаптивная        | O(n log² n) / O(n log² n) / O(n log² n)             |
| **Bogosort**                                     | Устойчивая                                             | Внутренняя           | На месте    | Неадаптивная        | O(n) / O(n·n!) / O(∞)                               |
| **Stooge sort**                                  | Устойчивая                                             | Внутренняя           | На месте    | Неадаптивная        | O(n².709) / O(n².709) / O(n².709)                   |
| **Timsort**                                      | Устойчивая                                             | Внутренняя           | Не на месте | Адаптивная          | O(n) / O(n log n) / O(n log n)                      |
| **Introsort**                                    | Неустойчивая                                           | Внутренняя           | На месте    | Неадаптивная        | O(n log n) / O(n log n) / O(n log n)                |
| **Блинная сортировка (Pancake sort)**            | Неустойчивая                                           | Внутренняя           | На месте    | Неадаптивная        | O(n) / O(n²) / O(n²)                                |
| **Блочная сортировка (Block sort)**              | Устойчивая                                             | Внутренняя           | Не на месте | Частично            | O(n log n) / O(n log n) / O(n log n)                |
| **Быстрая (Хоара) сортировка (Quicksort)**       | Неустойчивая                                           | Внутренняя           | На месте    | Неадаптивная        | O(n log n) / O(n log n) / O(n²)                     |
| **Гномья сортировка (Gnome sort)**               | Устойчивая                                             | Внутренняя           | На месте    | Адаптивная          | O(n) / O(n²) / O(n²)                                |
| **Медленная сортировка (Slow sort)**             | Устойчивая                                             | Внутренняя           | На месте    | Неадаптивная        | O(n log n) / O(n log n) / O(2^n)                    |
| **Метод Шелла (Shell sort)**                     | Неустойчивая                                           | Внутренняя           | На месте    | Частично адаптивная | O(n) / O(n^(3/2)) / O(n²) (зависит от инкрементов)  |
| **Пирамидальная сортировка (Heap sort)**         | Неустойчивая                                           | Внутренняя           | На месте    | Неадаптивная        | O(n log n) / O(n log n) / O(n log n)                |
| **Плавная сортировка (Smoothsort)**              | Неустойчивая                                           | Внутренняя           | На месте    | Адаптивная          | O(n) / O(n log n) / O(n log n)                      |
| **Поразрядная сортировка (Radix sort)**          | Устойчивая                                             | Внутренняя           | Не на месте | Неадаптивная        | O(n·k) / O(n·k) / O(n·k), k — длина ключа           |
| **Пузырьковая сортировка (Bubble sort)**         | Устойчивая                                             | Внутренняя           | На месте    | Адаптивная          | O(n) / O(n²) / O(n²)                                |
| **Сортировка выбором (Selection sort)**          | Неустойчивая                                           | Внутренняя           | На месте    | Неадаптивная        | O(n²) / O(n²) / O(n²)                               |
| **Сортировка деревом (Tree sort)**               | Устойчивая (если использовать сбалансированное дерево) | Внутренняя           | Не на месте | Неадаптивная        | O(n log n) / O(n log n) / O(n²)                     |
| **Сортировка подсчетом (Counting sort)**         | Устойчивая                                             | Внутренняя           | Не на месте | Неадаптивная        | O(n + k) / O(n + k) / O(n + k), k — диапазон ключей |
| **Сортировка перемешиванием (Shuffle sort)**     | Устойчивая                                             | Внутренняя           | На месте    | Неадаптивная        | O(n log n) / O(n log n) / O(n log n)                |
| **Сортировка расческой (Comb sort)**             | Неустойчивая                                           | Внутренняя           | На месте    | Частично            | O(n) / O(n²/2^p) / O(n²)                            |
| **Сортировка слиянием (Merge sort)**             | Устойчивая                                             | Внутренняя / Внешняя | Не на месте | Неадаптивная        | O(n log n) / O(n log n) / O(n log n)                |
| **Сортировка чёт-нечет (Odd-even sort)**         | Устойчивая                                             | Внутренняя           | На месте    | Частично            | O(n) / O(n²) / O(n²)                                |
| **Топологическая сортировка (Topological sort)** | Неустойчивая                                           | Внутренняя           | На месте    | Неадаптивная        | O(V + E), V — вершины, E — ребра                    |
| **Шейкерная сортировка (Cocktail sort)**         | Устойчивая                                             | Внутренняя           | На месте    | Адаптивная          | O(n) / O(n²) / O(n²)                                |

## Задание 2
Быстрая сортировка

## Быстрая сортировка (Хоара)
Общее описание
Быстрая сортировка — это эффективный алгоритм сортировки, разработанный британским ученым Тони Хоаром в 1960 году. Алгоритм использует стратегию "разделяй и властвуй" и является одним из самых быстрых алгоритмов сортировки на практике.

Принцип работы
Алгоритм работает по следующему принципу:

Выбор опорного элемента - из массива выбирается один элемент (pivot)

Разделение массива - массив переупорядочивается так, что:

Все элементы, меньшие опорного, помещаются слева от него

Все элементы, большие опорного, помещаются справа от него

Опорный элемент занимает свою окончательную позицию

Рекурсивное применение - алгоритм рекурсивно применяется к двум подмассивам слева и справа от опорного элемента

## Сложность
| Тип сложности  | Оценка                              |
| -------------- | ----------------------------------- |
| Лучший случай  | O(n log n)                          |
| Средний случай | O(n log n)                          |
| Худший случай  | O(n²)                               |

## Сортировка перемешиванием (Shaker Sort)

Общее описание
Сортировка перемешиванием, также известная как коктейльная сортировка, является улучшенной версией пузырьковой сортировки. Алгоритм был разработан для устранения главного недостатка пузырьковой сортировки — медленного "всплытия" маленьких элементов.

Принцип работы
Алгоритм выполняет попеременные проходы по массиву в двух направлениях:

Проход слева направо - как в пузырьковой сортировке, наибольшие элементы "всплывают" в конец массива

Проход справа налево - наименьшие элементы "тонут" в начало массива

Сужение диапазона - после каждого полного прохода границы неотсортированной части массива сужаются с обоих концов

Сложность:
| Тип сложности  | Оценка                              |
| -------------- | ----------------------------------- |
| Лучший случай  | O(n)                                |
| Средний случай | O(n²)                               |
| Худший случай  | O(n²)                               |

## Задание 3

Блок-схема алгоритма быстрой сортировки:

Объяснение блоков блок-схемы быстрой сортировки
Основные переменные:
low - начальный индекс текущего подмассива

high - конечный индекс текущего подмассива

i - индекс для разделения элементов

j - индекс для прохода по массиву

pivot - опорный элемент для сравнения

pi - итоговый индекс опорного элемента после разделения

Блоки основной схемы:
1. Start - Начало алгоритма
Начальная точка выполнения программы

2. low < high? - Проверка условия рекурсии
yes → массив нужно сортировать (переход к разделению)

no → базовый случай рекурсии, массив из 0 или 1 элемента уже отсортирован

3. pi = partition(arr, low, high) - Вызов функции разделения
Разделяет массив на две части относительно опорного элемента

4. quicksort(arr, low, pi-1) - Рекурсивная сортировка левой части
Сортирует элементы МЕНЬШЕ опорного

5. quicksort(arr, pi+1, high) - Рекурсивная сортировка правой части
Сортирует элементы БОЛЬШЕ опорного

6. End - Конец алгоритма
Массив полностью отсортирован

Объяснение блоков сортировки перемешиванием
Основные переменные:
swapped - флаг, были ли обмены на последнем проходе

start - начальный индекс неотсортированной части

end - конечный индекс неотсортированной части

i - текущий индекс в цикле

Блоки алгоритма:
1. Start - Начало алгоритма
2. swapped = true, start = 0, end = n-1 - Инициализация
Устанавливаем начальные значения переменных

3. swapped == true? - Проверка необходимости продолжения
yes → были обмены, продолжаем сортировку

no → массив отсортирован, завершаем

4. swapped = false - Сброс флага обменов
Подготавливаем для нового прохода

5. i = start to end-1 - Проход слева направо
"Всплытие" больших элементов в конец

6. arr[i] > arr[i+1]? - Сравнение соседних элементов
yes → элементы в неправильном порядке

no → элементы в правильном порядке

7. swap arr[i] and arr[i+1], swapped = true - Обмен и установка флага
Меняем элементы местами и отмечаем, что был обмен

8. swapped == false? - Проверка после прямого прохода
yes → массив уже отсортирован, завершаем

no → продолжаем обратный проход

9. swapped = false, end = end - 1 - Подготовка обратного прохода
Сбрасываем флаг и уменьшаем правую границу

10. i = end-1 to start - Проход справа налево
"Тонутие" маленьких элементов в начало

11. arr[i] > arr[i+1]? - Сравнение соседних элементов
yes → элементы в неправильном порядке

no → элементы в правильном порядке

12. swap arr[i] and arr[i+1], swapped = true - Обмен и установка флага
Меняем элементы местами и отмечаем, что был обмен

13. start = start + 1 - Увеличение левой границы
Уменьшаем неотсортированную область слева

14. End - Конец алгоритма
Массив полностью отсортирован

## Задание 4

ФУНКЦИЯ quicksort(arr, low, high)
    ЕСЛИ low < high ТО
        // Разделяем массив и получаем индекс опорного элемента
        pi = partition(arr, low, high)
        
        // Рекурсивно сортируем элементы до и после раздела
        quicksort(arr, low, pi - 1)
        quicksort(arr, pi + 1, high)
    КОНЕЦ ЕСЛИ
КОНЕЦ ФУНКЦИИ

ФУНКЦИЯ shaker_sort(arr)
    n = длина(arr)
    
    // Флаг, указывающий были ли обмены
    swapped = ИСТИНА
    
    // Границы неотсортированной части
    start = 0
    end = n - 1
    
    // Продолжаем пока происходят обмены
    ПОКА swapped = ИСТИНА ВЫПОЛНЯТЬ
        swapped = ЛОЖЬ
        
        // Проход слева направо
        ДЛЯ i = start ДО end - 1 ВЫПОЛНЯТЬ
            ЕСЛИ arr[i] > arr[i + 1] ТО
                обменять(arr[i], arr[i + 1])
                swapped = ИСТИНА
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
        
        // Если не было обменов - массив отсортирован
        ЕСЛИ swapped = ЛОЖЬ ТО
            ВЫЙТИ ИЗ ЦИКЛА
        КОНЕЦ ЕСЛИ
        
        swapped = ЛОЖЬ
        end = end - 1  // Уменьшаем правую границу
        
        // Проход справа налево
        ДЛЯ i = end - 1 ВНИЗ ДО start ВЫПОЛНЯТЬ
            ЕСЛИ arr[i] > arr[i + 1] ТО
                обменять(arr[i], arr[i + 1])
                swapped = ИСТИНА
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
        
        start = start + 1  // Увеличиваем левую границу
    КОНЕЦ ЦИКЛА
    
    ВЕРНУТЬ arr
КОНЕЦ ФУНКЦИИ

## Задание 5

## Быстрая сортировка (Quicksort)
Достоинства:
Высокая производительность - в среднем случае O(n log n), один из самых быстрых алгоритмов на практике

Эффективное использование кэша - хорошая локальность ссылок благодаря работе с соседними элементами

In-place сортировка - требует всего O(log n) дополнительной памяти для стека вызовов

Хорошо масштабируется - отлично работает на больших массивах данных

Простота реализации - базовый алгоритм легко понять и запрограммировать

Эффективен для случайных данных - показывает лучшие результаты на несортированных массивах

Недостатки:
Худший случай O(n²) - при неудачном выборе опорного элемента (уже отсортированный массив)

Неустойчивость - не сохраняет относительный порядок равных элементов

Зависимость от выбора опора - производительность сильно зависит от стратегии выбора pivot

Рекурсивные вызовы - могут привести к переполнению стека на очень больших массивах

Неэффективен на маленьких массивах - проигрывает простым алгоритмам при n < 10-20

Сложность анализа - математический анализ нетривиален из-за вероятностной природы

## Сортировка перемешиванием (Shaker Sort)
Достоинства:
Устойчивость - сохраняет относительный порядок равных элементов

Адаптивность - эффективен на частично отсортированных массивах (O(n) в лучшем случае)

In-place сортировка - требует всего O(1) дополнительной памяти

Простота реализации - легко понять, отладить и модифицировать

Двойное направление - устраняет проблему "черепах" пузырьковой сортировки

Детерминированность - всегда одинаковое количество операций для одинаковых входных данных

Недостатки:
Низкая производительность - O(n²) в среднем и худшем случаях

Неэффективен на больших массивах - становится непрактичным при n > 1000

Медленная работа на случайных данных - много избыточных сравнений и обменов

Ограниченная применимость - в основном используется в образовательных целях

Плохая масштабируемость - время работы быстро растет с увеличением n

Избыточные проходы - продолжает работать даже когда массив почти отсортирован

## Задание 6


```python
def quicksort(arr: List[int], low: int = 0, high: int = None) -> List[int]:
    if high is None:
        high = len(arr) - 1
    
    if low < high:
        pi = partition(arr, low, high)
        quicksort(arr, low, pi - 1)
        quicksort(arr, pi + 1, high)
    return arr

def partition(arr: List[int], low: int, high: int) -> int:
    pivot = arr[high]
    i = low - 1
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

def shaker_sort(arr: List[int]) -> List[int]:
    n = len(arr)
    swapped = True
    start = 0
    end = n - 1
    
    while swapped:
        swapped = False
        
        for i in range(start, end):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                swapped = True
        
        if not swapped:
            break
            
        swapped = False
        end -= 1
        
        for i in range(end - 1, start - 1, -1):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                swapped = True
                
        start += 1
    
    return arr
```

## Задание 7


```python
def test_algorithms():
    """Тестирование корректности реализации алгоритмов"""
    test_arrays = [
        [64, 34, 25, 12, 22, 11, 90],
        [5, 2, 4, 6, 1, 3],
        [1],
        [],
        [3, 3, 3, 3],
        [5, 4, 3, 2, 1]
    ]
    
    for i, arr in enumerate(test_arrays):
        arr1 = arr.copy()
        arr2 = arr.copy()
        
        quicksort_result = quicksort(arr1)
        shaker_result = shaker_sort(arr2)
        python_sorted = sorted(arr)
        
        print(f"Тест {i+1}: {arr}")
        print(f"Quicksort: {quicksort_result}")
        print(f"Shaker sort: {shaker_result}")
        print("-" * 30)
```

Тестирование корректности сортировки:
==================================================
Тест 1: [64, 34, 25, 12, 22, 11, 90]
Quicksort: [11, 12, 22, 25, 34, 64, 90]
Shaker sort: [11, 12, 22, 25, 34, 64, 90]
------------------------------
Тест 2: [5, 2, 4, 6, 1, 3]
Quicksort: [1, 2, 3, 4, 5, 6]
Shaker sort: [1, 2, 3, 4, 5, 6]
------------------------------
Тест 3: [1]
Quicksort: [1] 
Shaker sort: [1]
------------------------------
Тест 4: []
Quicksort: [] 
Shaker sort: [] 
------------------------------
Тест 5: [3, 3, 3, 3]
Quicksort: [3, 3, 3, 3] 
Shaker sort: [3, 3, 3, 3] 
------------------------------
Тест 6: [5, 4, 3, 2, 1]
Quicksort: [1, 2, 3, 4, 5] 
Shaker sort: [1, 2, 3, 4, 5] 
------------------------------

## Задание 8

| Шаг | low | high | Массив | Действие |
|-----|-----|------|--------|----------|
| 1 | 0 | 3 | [5, 3, 4, 1] | Вызов quicksort(0, 3) |
| 2 | 0 | 3 | [5, 3, 4, 1] | pivot = arr[3] = 1 |
| 3 | 0 | 3 | [1, 3, 4, 5] | partition: i=-1, j=0: 5>1 → нет<br>j=1: 3>1 → нет<br>j=2: 4>1 → нет<br>swap arr[0] и arr[3] → pi=0 |
| 4 | 0 | -1 | [1, 3, 4, 5] | quicksort(0, -1) → пропуск |
| 5 | 1 | 3 | [1, 3, 4, 5] | Вызов quicksort(1, 3) |
| 6 | 1 | 3 | [1, 3, 4, 5] | pivot = arr[3] = 5 |
| 7 | 1 | 3 | [1, 3, 4, 5] | partition: i=0, j=1: 3≤5 → i=1, swap arr[1] с собой<br>j=2: 4≤5 → i=2, swap arr[2] с собой<br>swap arr[3] с собой → pi=3 |
| 8 | 1 | 2 | [1, 3, 4, 5] | Вызов quicksort(1, 2) |
| 9 | 1 | 2 | [1, 3, 4, 5] | pivot = arr[2] = 4 |
| 10 | 1 | 2 | [1, 3, 4, 5] | partition: i=0, j=1: 3≤4 → i=1, swap arr[1] с собой<br>swap arr[2] с собой → pi=2 |
| 11 | 1 | 1 | [1, 3, 4, 5] | quicksort(1, 1) → пропуск |
| 12 | 3 | 2 | [1, 3, 4, 5] | quicksort(3, 2) → пропуск |
| 13 | 4 | 3 | [1, 3, 4, 5] | quicksort(4, 3) → пропуск |
| 14 | - | - | [1, 3, 4, 5] | **Результат: [1, 3, 4, 5]** |

| Шаг | swapped | start | end | Массив | Действие |
|-----|---------|-------|-----|--------|----------|
| 1 | true | 0 | 3 | [5, 3, 4, 1] | Инициализация |
| 2 | false | 0 | 3 | [5, 3, 4, 1] | Начало цикла |
| 3 | - | 0 | 3 | [5, 3, 4, 1] | **Проход слева направо:** |
| 4 | - | 0 | 3 | [3, 5, 4, 1] | i=0: 5>3 → swap, swapped=true |
| 5 | - | 0 | 3 | [3, 4, 5, 1] | i=1: 5>4 → swap, swapped=true |
| 6 | - | 0 | 3 | [3, 4, 1, 5] | i=2: 5>1 → swap, swapped=true |
| 7 | true | 0 | 3 | [3, 4, 1, 5] | Конец прямого прохода |
| 8 | false | 0 | 2 | [3, 4, 1, 5] | swapped=false, end=2 |
| 9 | - | 0 | 2 | [3, 4, 1, 5] | **Проход справа налево:** |
| 10 | - | 0 | 2 | [3, 1, 4, 5] | i=1: 4>1 → swap, swapped=true |
| 11 | - | 0 | 2 | [1, 3, 4, 5] | i=0: 3>1 → swap, swapped=true |
| 12 | true | 1 | 2 | [1, 3, 4, 5] | Конец обратного прохода, start=1 |
| 13 | false | 1 | 2 | [1, 3, 4, 5] | Начало нового цикла |
| 14 | - | 1 | 2 | [1, 3, 4, 5] | **Проход слева направо:** |
| 15 | - | 1 | 2 | [1, 3, 4, 5] | i=1: 3≤4 → нет обмена |
| 16 | false | 1 | 2 | [1, 3, 4, 5] | Конец прохода, swapped=false |
| 17 | - | - | - | [1, 3, 4, 5] | **Выход из цикла, результат: [1, 3, 4, 5]** |

| j | arr[j] | arr[j] ≤ pivot? | i | Массив после обмена |
|---|--------|-----------------|---|---------------------|
| 0 | 5 | 5 ≤ 1?  Нет | -1 | [5, 3, 4, 1] |
| 1 | 3 | 3 ≤ 1?  Нет | -1 | [5, 3, 4, 1] |
| 2 | 4 | 4 ≤ 1?  Нет | -1 | [5, 3, 4, 1] |

| Алгоритм | Количество операций | Время выполнения | Эффективность |
|----------|---------------------|------------------|---------------|
| Быстрая сортировка | 3 рекурсивных вызова | Быстро | Высокая |
| Сортировка перемешиванием | 2 полных прохода | Медленнее | Средняя |

## Задания 9,10,11


```python
import random, usage_time
import matplotlib.pyplot as plt
import numpy as np

n1_n2_n3_n4 = [1000, 5000, 10000, 100000]
num_trials = 3

results = {
    "Quicksort": {"sorted": [], "reverse": [], "random": []},
    "Shaker Sort": {"sorted": [], "reverse": [], "random": []}
}

def quicksort(arr, low=0, high=None):
    if high is None:
        high = len(arr) - 1
    if low < high:
        pi = partition(arr, low, high)
        quicksort(arr, low, pi - 1)
        quicksort(arr, pi + 1, high)
    return arr

def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

def shaker_sort(arr):
    n = len(arr)
    swapped = True
    start = 0
    end = n - 1
    while swapped:
        swapped = False
        for i in range(start, end):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                swapped = True
        if not swapped:
            break
        swapped = False
        end -= 1
        for i in range(end - 1, start - 1, -1):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                swapped = True
        start += 1
    return arr

for n in n1_n2_n3_n4:
    arr_sorted = list(range(n))
    arr_reverse = list(range(n, 0, -1))
    arr_random = [random.randint(1, n) for _ in range(n)]

    # Для Quicksort
    quicksort_func = usage_time.get_usage_time()(lambda arr: quicksort(arr, 0, len(arr)-1))
    
    t_sorted = sum(quicksort_func(arr_sorted.copy()) for _ in range(num_trials)) / num_trials
    t_reverse = sum(quicksort_func(arr_reverse.copy()) for _ in range(num_trials)) / num_trials
    t_random = sum(quicksort_func(arr_random.copy()) for _ in range(num_trials)) / num_trials

    results["Quicksort"]["sorted"].append(t_sorted)
    results["Quicksort"]["reverse"].append(t_reverse)
    results["Quicksort"]["random"].append(t_random)

    # Для Shaker Sort
    if n != 100000:
        shaker_sort_func = usage_time.get_usage_time()(shaker_sort)
        t_sorted = sum(shaker_sort_func(arr_sorted.copy()) for _ in range(num_trials)) / num_trials
        t_reverse = sum(shaker_sort_func(arr_reverse.copy()) for _ in range(num_trials)) / num_trials
        t_random = sum(shaker_sort_func(arr_random.copy()) for _ in range(num_trials)) / num_trials

        results["Shaker Sort"]["sorted"].append(t_sorted)
        results["Shaker Sort"]["reverse"].append(t_reverse)
        results["Shaker Sort"]["random"].append(t_random)
    else:
        results["Shaker Sort"]["sorted"].append(np.nan)
        results["Shaker Sort"]["reverse"].append(np.nan)
        results["Shaker Sort"]["random"].append(np.nan)

fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Quicksort
axes[0].plot(n1_n2_n3_n4, results["Quicksort"]["sorted"], 'go-', label='Sorted array')
axes[0].plot(n1_n2_n3_n4, results["Quicksort"]["reverse"], 'ro-', label='Reverse array')
axes[0].plot(n1_n2_n3_n4, results["Quicksort"]["random"], 'bo-', label='Random array')
axes[0].set_title('Quicksort execution time')
axes[0].set_xlabel('Number of elements')
axes[0].set_ylabel('Time (seconds)')
axes[0].legend()
axes[0].grid(True)

# Shaker Sort
axes[1].plot(n1_n2_n3_n4[:3], results["Shaker Sort"]["sorted"][:3], 'go-', label='Sorted array')
axes[1].plot(n1_n2_n3_n4[:3], results["Shaker Sort"]["reverse"][:3], 'ro-', label='Reverse array')
axes[1].plot(n1_n2_n3_n4[:3], results["Shaker Sort"]["random"][:3], 'bo-', label='Random array')
axes[1].set_title('Shaker Sort execution time')
axes[1].set_xlabel('Number of elements')
axes[1].set_ylabel('Time (seconds)')
axes[1].legend()
axes[1].grid(True)

plt.tight_layout()
plt.show()
```
