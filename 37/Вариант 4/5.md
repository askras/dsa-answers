# Хеш-функции и хеш-таблицы

Ломовский Е.М. ИУ10-37

### Задание 1: Хеш-таблица с методом цепочек

```python
class HashTableChaining:
    def __init__(self, capacity=10):
        self.capacity = capacity
        self.buckets = [[] for _ in range(capacity)]
        self.count = 0
    
    def _compute_hash(self, key):
        if isinstance(key, int):
            return key % self.capacity
        elif isinstance(key, str):
            hash_val = 2166136261
            for char in key:
                hash_val = (hash_val * 16777619) ^ ord(char)
            return hash_val % self.capacity
        else:
            return hash(key) % self.capacity
    
    def put(self, key, value):
        if self.count / self.capacity > 0.7:
            self._resize()
        
        idx = self._compute_hash(key)
        bucket = self.buckets[idx]
        
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return
        
        bucket.append((key, value))
        self.count += 1
    
    def get(self, key):
        idx = self._compute_hash(key)
        bucket = self.buckets[idx]
        
        for k, v in bucket:
            if k == key:
                return v
        return None
    
    def remove(self, key):
        idx = self._compute_hash(key)
        bucket = self.buckets[idx]
        
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket.pop(i)
                self.count -= 1
                return True
        return False
    
    def _resize(self):
        old_buckets = self.buckets
        self.capacity *= 2
        self.buckets = [[] for _ in range(self.capacity)]
        self.count = 0
        
        for bucket in old_buckets:
            for key, value in bucket:
                self.put(key, value)

ht = HashTableChaining(5)
ht.put("книга", 500)
ht.put("ручка", 30)
ht.put("тетрадь", 45)
ht.put("карандаш", 20)

print(f"книга: {ht.get('книга')}")
print(f"ручка: {ht.get('ручка')}")

ht.remove("ручка")
print(f"ручка после удаления: {ht.get('ручка')}")

книга: 500
ручка: 30
ручка после удаления: None

### Задание 2: Хеш-таблица с открытой адресацией

```python
class HashTableOpenAddressing:
    def __init__(self, capacity=10):
        self.capacity = capacity
        self.table = [None] * capacity
        self.EMPTY = None
        self.DELETED = object()
        self.size = 0
    
    def _hash1(self, key):
        if isinstance(key, str):
            h = 0
            for char in key:
                h = (h * 31 + ord(char)) % self.capacity
            return h
        return key % self.capacity
    
    def _hash2(self, key):
        return 1 + (key % (self.capacity - 1)) if isinstance(key, int) else 1
    
    def _probe(self, key, i):
        return (self._hash1(key) + i * self._hash2(key if isinstance(key, int) else sum(ord(c) for c in str(key)))) % self.capacity
    
    def insert(self, key, value):
        if self.size / self.capacity > 0.75:
            self._rehash()
        
        for i in range(self.capacity):
            idx = self._probe(key, i)
            if self.table[idx] in (self.EMPTY, self.DELETED) or self.table[idx] and self.table[idx][0] == key:
                if self.table[idx] is None or self.table[idx] is self.DELETED:
                    self.size += 1
                self.table[idx] = (key, value)
                return
        raise Exception("Таблица переполнена")
    
    def find(self, key):
        for i in range(self.capacity):
            idx = self._probe(key, i)
            if self.table[idx] is None:
                return None
            if self.table[idx] is not self.DELETED and self.table[idx][0] == key:
                return self.table[idx][1]
        return None
    
    def delete(self, key):
        for i in range(self.capacity):
            idx = self._probe(key, i)
            if self.table[idx] is None:
                return False
            if self.table[idx] is not self.DELETED and self.table[idx][0] == key:
                self.table[idx] = self.DELETED
                self.size -= 1
                return True
        return False
    
    def _rehash(self):
        old_table = self.table
        self.capacity *= 2
        self.table = [None] * self.capacity
        self.size = 0
        
        for item in old_table:
            if item not in (None, self.DELETED):
                self.insert(item[0], item[1])

hta = HashTableOpenAddressing(7)
hta.insert("python", 1991)
hta.insert("java", 1995)
hta.insert("javascript", 1995)
hta.insert("c++", 1985)

print(f"python: {hta.find('python')}")
print(f"java: {hta.find('java')}")

hta.delete("java")
print(f"java после удаления: {hta.find('java')}")

python: 1991
java: 1995
java после удаления: None  

### Задание 3: Простая модель блокчейна

```python
import hashlib
import time
import json

class Block:
    def __init__(self, index, transactions, timestamp, previous_hash, nonce=0):
        self.index = index
        self.transactions = transactions
        self.timestamp = timestamp
        self.previous_hash = previous_hash
        self.nonce = nonce
        self.hash = self.calculate_hash()
    
    def calculate_hash(self):
        block_string = json.dumps({
            "index": self.index,
            "transactions": self.transactions,
            "timestamp": self.timestamp,
            "previous_hash": self.previous_hash,
            "nonce": self.nonce
        }, sort_keys=True)
        return hashlib.sha256(block_string.encode()).hexdigest()
    
    def mine_block(self, difficulty):
        target = "0" * difficulty
        while self.hash[:difficulty] != target:
            self.nonce += 1
            self.hash = self.calculate_hash()
        print(f"Блок найден: {self.hash}")

class SimpleBlockchain:
    def __init__(self):
        self.chain = [self.create_genesis_block()]
        self.difficulty = 2
        self.pending_transactions = []
    
    def create_genesis_block(self):
        return Block(0, ["Генезис блок"], time.time(), "0")
    
    def get_latest_block(self):
        return self.chain[-1]
    
    def add_transaction(self, transaction):
        self.pending_transactions.append(transaction)
    
    def mine_pending_transactions(self):
        block = Block(
            len(self.chain),
            self.pending_transactions,
            time.time(),
            self.get_latest_block().hash
        )
        block.mine_block(self.difficulty)
        self.chain.append(block)
        self.pending_transactions = []
    
    def is_chain_valid(self):
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i-1]
            
            if current_block.hash != current_block.calculate_hash():
                return False
            if current_block.previous_hash != previous_block.hash:
                return False
        return True

bc = SimpleBlockchain()

bc.add_transaction("Алиса -> Боб: 50 BTC")
bc.add_transaction("Боб -> Кэрол: 25 BTC")
bc.mine_pending_transactions()

bc.add_transaction("Кэрол -> Дэйв: 10 BTC")
bc.mine_pending_transactions()

print(f"Цепочка валидна: {bc.is_chain_valid()}")
print(f"Длина цепочки: {len(bc.chain)}")

for i, block in enumerate(bc.chain):
    print(f"Блок {i}: {block.hash}")

Блок найден: 001e69af2c030c8c6adb5d44547fb8e665b36655405077d10d83b22413365ed0

Блок найден: 008cd5e7b6b8ca8c5baffb81260f0d74bc97d65e58266b1a1395d98de3745b8d

Цепочка валидна: True

Длина цепочки: 3

Блок 0: 9f32febe8cb995380e5e4a14693f952c81c7f0630c6e7196737fa7db276b20c7     
Блок 1: 001e69af2c030c8c6adb5d44547fb8e665b36655405077d10d83b22413365ed0     
Блок 2: 008cd5e7b6b8ca8c5baffb81260f0d74bc97d65e58266b1a1395d98de3745b8d  

### Задание 4: Проверка пересечения массивов

```python
def check_array_intersection(arr1, arr2):
    set1 = set(arr1)
    for item in arr2:
        if item in set1:
            return True
    return False

arr1 = [1, 2, 3, 4, 5]
arr2 = [5, 6, 7, 8, 9]
arr3 = [10, 11, 12]

print(f"arr1 и arr2: {check_array_intersection(arr1, arr2)}")
print(f"arr1 и arr3: {check_array_intersection(arr1, arr3)}")

True

### Задание 5: Проверка уникальности элементов

```python
def check_all_unique(arr):
    seen = set()
    for item in arr:
        if item in seen:
            return False
        seen.add(item)
    return True

test1 = [1, 2, 3, 4, 5]
test2 = [1, 2, 3, 2, 4]

print(f"test1 уникален: {check_all_unique(test1)}")
print(f"test2 уникален: {check_all_unique(test2)}")

False

### Задание 6: Поиск пар с заданной суммой

```python
def find_sum_pairs(nums, target):
    pairs = []
    num_set = set()
    
    for num in nums:
        complement = target - num
        if complement in num_set:
            pair = (min(num, complement), max(num, complement))
            if pair not in pairs:
                pairs.append(pair)
        num_set.add(num)
    
    return pairs

numbers = [2, 7, 11, 15, 3, 6, 1, 5]
target_sum = 9

result = find_sum_pairs(numbers, target_sum)
print(f"Пары с суммой {target_sum}: {result}")

Пары с суммой 9: [(2, 7), (3, 6)]

### Задание 7: Проверка анаграмм

```python
def are_anagrams(s1, s2):
    if len(s1) != len(s2):
        return False
    
    char_count = {}
    for char in s1:
        char_count[char] = char_count.get(char, 0) + 1
    
    for char in s2:
        if char not in char_count:
            return False
        char_count[char] -= 1
        if char_count[char] == 0:
            del char_count[char]
    
    return len(char_count) == 0

word1 = "listen"
word2 = "silent"
word3 = "hello"

print(f"'{word1}' и '{word2}': {are_anagrams(word1, word2)}")
print(f"'{word1}' и '{word3}': {are_anagrams(word1, word3)}")

'listen' и 'silent': True
'listen' и 'hello': False  
