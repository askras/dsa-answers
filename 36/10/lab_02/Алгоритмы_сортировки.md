# Классификация алгоритмов сортировки

---

## Сортировка деревом

### Основные характеристики
| Критерий | Классификация |
|----------|---------------|
| **Устойчивость** | Неустойчивая |
| **Тип сортировки** | Внутренняя |
| **Доп. память** | Не на месте |
| **Адаптивность** | Неадаптивная |

### Сложность алгоритма
| Сценарий | Сравнения C(n) | Перемещения M(n) |
|----------|----------------|------------------|
| **Лучший случай** | O(n log n) | O(n) |
| **Средний случай** | O(n log n) | O(n) |
| **Худший случай** | O(n²) | O(n) |

## Сортировка выбором

### Основные характеристики
| Критерий | Классификация |
|----------|---------------|
| **Устойчивость** | Неустойчивая |
| **Тип сортировки** | Внутренняя |
| **Доп. память** | На месте |
| **Адаптивность** | Неадаптивная |

### Сложность алгоритма
| Сценарий | Сравнения C(n) | Перемещения M(n) |
|----------|----------------|------------------|
| **Лучший случай** | O(n²) | O(1) |
| **Средний случай** | O(n²) | O(n) |
| **Худший случай** | O(n²) | O(n) |


# Теоретическое описание алгоритмов сортировки

---

## Сортировка деревом

Сортировка деревом использует структуру данных "бинарное дерево поиска" (BST) для организации элементов. Алгоритм состоит из двух основных этапов: построение дерева и обход дерева в порядке возрастания.

### Принцип работы
1. **Построение дерева**: Каждый элемент исходного массива последовательно вставляется в бинарное дерево поиска
2. **Обход дерева**: Выполняется симметричный (in-order) обход дерева, который возвращает элементы в отсортированном порядке

## Сортировка выбором

Алгоритм разделяет массив на две части: отсортированную (в начале) и неотсортированную (оставшаяся часть). На каждой итерации находится минимальный элемент из неотсортированной части и помещается в конец отсортированной части.

### Принцип работы
1. **Инициализация**: Отсортированная часть пуста, неотсортированная - весь массив
2. **Поиск минимума**: В неотсортированной части находится минимальный элемент
3. **Обмен**: Минимальный элемент меняется местами с первым элементом неотсортированной части
4. **Расширение**: Граница отсортированной части сдвигается на один элемент
5. **Повторение**: Шаги 2-4 повторяются пока есть неотсортированные элементы

# Блок-схемы алгоритмов

---

## Сортировка деревом

![png](Images/block_tree.png)

## Сортировка выбором

![png](Images/block_choose.png)

# Псевдокод

---

## Сортировка деревом

```
class TreeNode:
    value
    left
    right

function treeSort(arr):
    root = null
    for each value in arr:
        root = insert(root, value)
    result = []
    inorderTraversal(root, result)
    return result

function insert(node, value):
    if node is null:
        return new TreeNode(value)
    if value < node.value:
        node.left = insert(node.left, value)
    else:
        node.right = insert(node.right, value)
    return node

function inorderTraversal(node, result):
    if node is not null:
        inorderTraversal(node.left, result)
        result.append(node.value)
        inorderTraversal(node.right, result)
```

## Сортировка выбором

```
function selectionSort(arr):
    n = length(arr)
    for i from 0 to n-2:
        min_index = i
        for j from i+1 to n-1:
            if arr[j] < arr[min_index]:
                min_index = j
        swap arr[i] and arr[min_index]
    return arr
```

# Достоинства и недостатки

---

## Сортировка деревом

### Достоинства:
1. В среднем случае O(n log n)
2. Стабильная сложность для частично отсортированных данных

### Недостатки:
1. Требует O(n) дополнительной памяти
2. В худшем случае O(n²) для несбалансированного дерева
3. Сложная реализация

## Сортировка выбором

### Достоинства:
1. Простая реализация
2. In-place сортировка (O(1) дополнительной памяти)

### Недостатки:
1. Всегда O(n²) независимо от входных данных
2. Неустойчивая

## Реализация алгоритмов
---


```python
import time
import random
import sys
import matplotlib.pyplot as plt

sys.setrecursionlimit(200000)

# Сортировка деревом
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def tree_sort(arr):
    def insert(node, value):
        if node is None:
            return TreeNode(value)
        if value < node.value:
            node.left = insert(node.left, value)
        else:
            node.right = insert(node.right, value)
        return node
    
    def inorder_traversal(node, result):
        if node:
            inorder_traversal(node.left, result)
            result.append(node.value)
            inorder_traversal(node.right, result)
    
    root = None
    for value in arr:
        root = insert(root, value)
    
    result = []
    inorder_traversal(root, result)
    return result

# Сортировка выбором
def selection_sort(arr):
    n = len(arr)
    for i in range(n-1):
        min_index = i
        for j in range(i+1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr

def test_sorting_algorithms():
    test_arrays = [
        [64, 34, 25, 12, 22, 11, 90],
        [5, 2, 4, 6, 1, 3],
        [1],
        []
    ]
    
    for arr in test_arrays:
        tree_result = tree_sort(arr.copy())
        selection_result = selection_sort(arr.copy())
        expected = sorted(arr.copy())
        
        print(f"Исходный: {arr}")
        print(f"Tree sort: {tree_result}, Корректно: {tree_result == expected}")
        print(f"Selection sort: {selection_result}, Корректно: {selection_result == expected}")
        print()

test_sorting_algorithms()
```

    Исходный: [64, 34, 25, 12, 22, 11, 90]
    Tree sort: [11, 12, 22, 25, 34, 64, 90], Корректно: True
    Selection sort: [11, 12, 22, 25, 34, 64, 90], Корректно: True
    
    Исходный: [5, 2, 4, 6, 1, 3]
    Tree sort: [1, 2, 3, 4, 5, 6], Корректно: True
    Selection sort: [1, 2, 3, 4, 5, 6], Корректно: True
    
    Исходный: [1]
    Tree sort: [1], Корректно: True
    Selection sort: [1], Корректно: True
    
    Исходный: []
    Tree sort: [], Корректно: True
    Selection sort: [], Корректно: True
    


## Ручная трассировка

---
```
МАССИВ: [64, 25, 12, 22]
```

### Сортировка выбором
```
Итерация 0: [64, 25, 12, 22] min_index=2 → swap(0,2) → [12, 25, 64, 22]
Итерация 1: [12, 25, 64, 22] min_index=3 → swap(1,3) → [12, 22, 64, 25]
Итерация 2: [12, 22, 64, 25] min_index=3 → swap(2,3) → [12, 22, 25, 64]
Результат: [12, 22, 25, 64]
```

### Сортировка деревом
```
1) Построение дерева:

        [64]
        /  \
      [25] []
      /  \
    [12] []
    /  \
   []  [22]

2) Начинаем с корня 64:
Идем влево к 25
Идем влево к 12
У 12: левый потомок null → посещаем 12
Правый потомок 22 → идем к 22
У 22: левый потомок null → посещаем 22
Правый потомок null → возвращаемся
Возвращаемся к 12 (уже посещен) → возвращаемся к 25
Посещаем 25
Правый потомок 25 = null → возвращаемся к 64
Посещаем 64
Правый потомок 64 = null → обход завершен
посещения узлов: 12 → 22 → 25 → 64

Итоговый массив: [12, 22, 25, 64]
```

## Сравнение алгоритмов сортировки массивов, содержащих 1000, 5000, 10000 элементов.


```python
def performance_test():
    sizes = [1000, 5000, 10000]
    results = {'tree': [], 'selection': []}
    
    for size in sizes:
        print(f"\nТестирование для {size} элементов:")
        
        # Генерация тестовых данных
        sorted_arr = list(range(size))
        reverse_arr = list(range(size, 0, -1))
        random_arr = random.sample(range(size * 10), size)
        
        test_cases = {
            'Упорядоченный': sorted_arr,
            'Обратный порядок': reverse_arr,
            'Случайный': random_arr
        }
        
        for case_name, test_arr in test_cases.items():
            print(f"\n{case_name} массив:")
            
            arr_copy = test_arr.copy()
            start_time = time.time()
            tree_sort(arr_copy)
            tree_time = time.time() - start_time
            results['tree'].append((size, case_name, tree_time))
            print(f"Tree sort: {tree_time:.4f} сек")
            
            arr_copy = test_arr.copy()
            start_time = time.time()
            selection_sort(arr_copy)
            selection_time = time.time() - start_time
            results['selection'].append((size, case_name, selection_time))
            print(f"Selection sort: {selection_time:.4f} сек")
    
    return results

# Запуск тестов
results = performance_test()

# Построение графиков
def plot_results(results):
    sizes = [1000, 5000, 10000]
    cases = ['Упорядоченный', 'Обратный порядок', 'Случайный']
    
    fig, axes = plt.subplots(1, 2, figsize=(15, 5))
    
    # Tree sort
    for case in cases:
        times = [t for s, c, t in results['tree'] if c == case]
        axes[0].plot(sizes[:len(times)], times, marker='o', label=case)
    
    axes[0].set_title('Сортировка деревом')
    axes[0].set_xlabel('Размер массива')
    axes[0].set_ylabel('Время (сек)')
    axes[0].legend()
    axes[0].grid(True)
    
    # Selection sort
    for case in cases:
        times = [t for s, c, t in results['selection'] if c == case]
        if times:
            axes[1].plot(sizes[:len(times)], times, marker='o', label=case)
    
    axes[1].set_title('Сортировка выбором')
    axes[1].set_xlabel('Размер массива')
    axes[1].set_ylabel('Время (сек)')
    axes[1].legend()
    axes[1].grid(True)
    
    plt.tight_layout()
    plt.show()

plot_results(results)
```

    
    Тестирование для 1000 элементов:
    
    Упорядоченный массив:
    Tree sort: 0.0697 сек
    Selection sort: 0.0148 сек
    
    Обратный порядок массив:
    Tree sort: 0.0469 сек
    Selection sort: 0.0141 сек
    
    Случайный массив:
    Tree sort: 0.0007 сек
    Selection sort: 0.0141 сек
    
    Тестирование для 5000 элементов:
    
    Упорядоченный массив:
    Tree sort: 1.2768 сек
    Selection sort: 0.3397 сек
    
    Обратный порядок массив:
    Tree sort: 1.2933 сек
    Selection sort: 0.3571 сек
    
    Случайный массив:
    Tree sort: 0.0048 сек
    Selection sort: 0.3507 сек
    
    Тестирование для 10000 элементов:
    
    Упорядоченный массив:
    Tree sort: 5.5318 сек
    Selection sort: 1.4610 сек
    
    Обратный порядок массив:
    Tree sort: 5.7043 сек
    Selection sort: 1.4532 сек
    
    Случайный массив:
    Tree sort: 0.0144 сек
    Selection sort: 1.4123 сек



    
![png](output_3_1.png)
    



```python

```
